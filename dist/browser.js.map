{
  "version": 3,
  "sources": ["babel-import:@babel/generator", "../src/index.ts", "../src/deobfuscator/index.ts", "babel-import:@babel/traverse", "../src/transforms/index.ts", "../src/transforms/mergeStrings.ts", "../src/deobfuscator/arrayRotator.ts", "../src/utils/matcher.ts", "../src/deobfuscator/controlFlowObject.ts", "../src/utils/ast.ts", "../src/utils/inline.ts", "../src/utils/rename.ts", "../src/deobfuscator/controlFlowSwitch.ts", "../src/deobfuscator/deadCode.ts", "../src/deobfuscator/decoder.ts", "../src/deobfuscator/inlineDecodedStrings.ts", "../src/deobfuscator/inlineDecoderWrappers.ts", "../src/deobfuscator/inlineObjectProps.ts", "../src/deobfuscator/stringArray.ts", "../src/deobfuscator/vm.ts", "../src/deobfuscator/debugProtection.ts", "../src/deobfuscator/mergeObjectAssignments.ts", "../src/deobfuscator/selfDefending.ts", "../src/extractor/index.ts", "../src/extractor/browserify/index.ts", "../src/utils/path.ts", "../src/extractor/bundle.ts", "../src/extractor/browserify/bundle.ts", "../src/extractor/module.ts", "../src/extractor/browserify/module.ts", "../src/extractor/webpack/index.ts", "../src/extractor/webpack/bundle.ts", "../src/extractor/webpack/esm.ts", "../src/extractor/webpack/getDefaultExport.ts", "../src/extractor/webpack/varInjection.ts", "../src/extractor/webpack/module.ts", "../src/transforms/blockStatement.ts", "../src/transforms/jsx.ts", "../src/transforms/jsx-new.ts", "../src/transforms/mangle.ts", "../src/transforms/sequence.ts", "../src/transforms/splitVariableDeclarations.ts", "../src/transforms/booleanIf.ts", "../src/transforms/computedProperties.ts", "../src/transforms/jsonParse.ts", "../src/transforms/mergeElseIf.ts", "../src/transforms/numberExpressions.ts", "../src/transforms/rawLiterals.ts", "../src/transforms/ternaryToIf.ts", "../src/transforms/unminifyBooleans.ts", "../src/transforms/void0ToUndefined.ts", "../src/transforms/yoda.ts", "../src/transforms/unminify.ts"],
  "sourcesContent": ["import module from '@babel/generator/lib/index.js';\n          export default module.default ?? module;\n          export * from '@babel/generator/lib/index.js';", "import generate from '@babel/generator';\nimport { parse } from '@babel/parser';\nimport * as m from '@codemod/matchers';\nimport debug from 'debug';\nimport { join, normalize } from 'node:path';\nimport deobfuscator from './deobfuscator';\nimport debugProtection from './deobfuscator/debugProtection';\nimport mergeObjectAssignments from './deobfuscator/mergeObjectAssignments';\nimport selfDefending from './deobfuscator/selfDefending';\nimport {\n  Sandbox,\n  createBrowserSandbox,\n  createNodeSandbox,\n} from './deobfuscator/vm';\nimport { unpackBundle } from './extractor';\nimport { Bundle } from './extractor/bundle';\nimport {\n  applyTransform,\n  applyTransformAsync,\n  applyTransforms,\n} from './transforms';\nimport blockStatement from './transforms/blockStatement';\nimport jsx from './transforms/jsx';\nimport jsxNew from './transforms/jsx-new';\nimport mangle from './transforms/mangle';\nimport sequence from './transforms/sequence';\nimport splitVariableDeclarations from './transforms/splitVariableDeclarations';\nimport unminify from './transforms/unminify';\n\nexport interface WebcrackResult {\n  code: string;\n  bundle: Bundle | undefined;\n  /**\n   * Save the deobufscated code and the extracted bundle to the given directory.\n   * @param path Output directory\n   */\n  save(path: string): Promise<void>;\n}\n\nexport interface Options {\n  /**\n   * Decompile react components to JSX.\n   * @default true\n   */\n  jsx?: boolean;\n  /**\n   * Extract modules from the bundle.\n   * @default true\n   */\n  unpack?: boolean;\n  /**\n   * Deobfuscate the code.\n   * @default true\n   */\n  deobfuscate?: boolean;\n  /**\n   * Mangle variable names.\n   * @default false\n   */\n  mangle?: boolean;\n  /**\n   * Assigns paths to modules based on the given matchers.\n   * This will also rewrite `require()` calls to use the new paths.\n   *\n   * @example\n   * ```js\n   * m => ({\n   *   './utils/color.js': m.regExpLiteral('^#([0-9a-f]{3}){1,2}$')\n   * })\n   * ```\n   */\n  mappings?: (\n    m: typeof import('@codemod/matchers')\n  ) => Record<string, m.Matcher<unknown>>;\n  /**\n   * Function that executes a code expression and returns the result (typically from the obfuscator).\n   */\n  sandbox?: Sandbox;\n}\n\nfunction mergeOptions(options: Options): asserts options is Required<Options> {\n  const mergedOptions: Required<Options> = {\n    jsx: true,\n    unpack: true,\n    deobfuscate: true,\n    mangle: false,\n    mappings: () => ({}),\n    sandbox: process.env.browser ? createBrowserSandbox() : createNodeSandbox(),\n    ...options,\n  };\n  Object.assign(options, mergedOptions);\n}\n\nexport async function webcrack(\n  code: string,\n  options: Options = {}\n): Promise<WebcrackResult> {\n  mergeOptions(options);\n\n  if (process.env.browser) {\n    debug.enable('webcrack:*');\n  }\n\n  const ast = parse(code, {\n    sourceType: 'unambiguous',\n    allowReturnOutsideFunction: true,\n    plugins: ['jsx'],\n  });\n\n  applyTransforms(\n    ast,\n    [blockStatement, sequence, splitVariableDeclarations],\n    'prepare'\n  );\n\n  if (options.deobfuscate)\n    await applyTransformAsync(ast, deobfuscator, options.sandbox);\n\n  // Normally unminify doesn't crawl the scope again, but when deobfuscation is disabled\n  // we have to do it for other transforms to work\n  const unminifyWrapper: typeof unminify = {\n    ...unminify,\n    visitor: () => ({ ...unminify.visitor(), noScope: options.deobfuscate }),\n  };\n  applyTransform(ast, unminifyWrapper);\n\n  if (options.mangle) applyTransform(ast, mangle);\n\n  // TODO: Also merge unminify visitor (breaks selfDefending/debugProtection atm)\n  applyTransforms(\n    ast,\n    [\n      // Have to run this after unminify to properly detect it\n      options.deobfuscate ? [selfDefending, debugProtection] : [],\n      options.jsx ? [jsx, jsxNew] : [],\n    ].flat()\n  );\n\n  if (options.deobfuscate) applyTransform(ast, mergeObjectAssignments);\n\n  // Unpacking modifies the same AST and may result in imports not at top level\n  // so the code has to be generated before\n  const outputCode = generate(ast, { jsescOption: { minimal: true } }).code;\n\n  const bundle = options.unpack\n    ? unpackBundle(ast, options.mappings(m))\n    : undefined;\n\n  return {\n    code: outputCode,\n    bundle,\n    async save(path) {\n      path = normalize(path);\n      if (process.env.browser) {\n        throw new Error('Not implemented.');\n      } else {\n        const { mkdir, writeFile } = await import('node:fs/promises');\n        await mkdir(path, { recursive: true });\n        await writeFile(join(path, 'deobfuscated.js'), outputCode, 'utf8');\n        await bundle?.save(path);\n      }\n    },\n  };\n}\n", "import debug from 'debug';\nimport {\n  applyTransform,\n  applyTransformAsync,\n  applyTransforms,\n  AsyncTransform,\n} from '../transforms';\nimport mergeStrings from '../transforms/mergeStrings';\nimport { findArrayRotator } from './arrayRotator';\nimport controlFlowObject from './controlFlowObject';\nimport controlFlowSwitch from './controlFlowSwitch';\nimport deadCode from './deadCode';\nimport { findDecoders } from './decoder';\nimport inlineDecodedStrings from './inlineDecodedStrings';\nimport inlineDecoderWrappers from './inlineDecoderWrappers';\nimport inlineObjectProps from './inlineObjectProps';\nimport { findStringArray } from './stringArray';\nimport { Sandbox, VMDecoder } from './vm';\n\n// https://astexplorer.net/#/gist/b1018df4a8daebfcb1daf9d61fe17557/4ff9ad0e9c40b9616956f17f59a2d9888cd62a4f\n\nexport default {\n  name: 'deobfuscate',\n  tags: ['unsafe'],\n  async run(ast, state, sandbox) {\n    const logger = debug('webcrack:deobfuscate');\n    if (!sandbox) return;\n\n    const stringArray = findStringArray(ast);\n    logger(\n      stringArray\n        ? `String Array: ${stringArray.length} strings`\n        : 'String Array: no'\n    );\n    if (!stringArray) return;\n\n    const rotator = findArrayRotator(stringArray);\n    logger(`String Array Rotate: ${rotator ? 'yes' : 'no'}`);\n\n    const decoders = findDecoders(stringArray);\n    logger(`String Array Encodings: ${decoders.length}`);\n\n    state.changes += applyTransform(ast, inlineObjectProps).changes;\n\n    for (const decoder of decoders) {\n      state.changes += applyTransform(\n        ast,\n        inlineDecoderWrappers,\n        decoder.path\n      ).changes;\n    }\n\n    const vm = new VMDecoder(sandbox, stringArray, decoders, rotator);\n    state.changes += (\n      await applyTransformAsync(ast, inlineDecodedStrings, { vm })\n    ).changes;\n\n    stringArray.path.remove();\n    rotator?.remove();\n    decoders.forEach(decoder => decoder.path.remove());\n    state.changes += 2 + decoders.length;\n\n    state.changes += applyTransforms(\n      ast,\n      [mergeStrings, deadCode, controlFlowObject, controlFlowSwitch],\n      'mergeStrings, deadCode, controlFlow'\n    ).changes;\n  },\n} satisfies AsyncTransform<Sandbox>;\n", "import module from '@babel/traverse/lib/index.js';\n          export default module.default ?? module;\n          export * from '@babel/traverse/lib/index.js';", "import traverse, { Node, TraverseOptions, visitors } from '@babel/traverse';\nimport debug from 'debug';\n\nconst logger = debug('webcrack:transforms');\n\nexport async function applyTransformAsync<TOptions>(\n  ast: Node,\n  transform: AsyncTransform<TOptions>,\n  options?: TOptions\n): Promise<TransformState> {\n  logger(`${transform.name}: started`);\n\n  const state: TransformState = { changes: 0 };\n\n  await transform.run?.(ast, state, options);\n  if (transform.visitor)\n    traverse(ast, transform.visitor(options), undefined, state);\n\n  logger(`${transform.name}: finished with ${state.changes} changes`);\n\n  return state;\n}\n\nexport function applyTransform<TOptions>(\n  ast: Node,\n  transform: Transform<TOptions>,\n  options?: TOptions\n): TransformState {\n  logger(`${transform.name}: started`);\n\n  const state: TransformState = { changes: 0 };\n\n  transform.run?.(ast, state, options);\n  if (transform.visitor)\n    traverse(ast, transform.visitor(options), undefined, state);\n\n  logger(`${transform.name}: finished with ${state.changes} changes`);\n\n  return state;\n}\n\nexport function applyTransforms(\n  ast: Node,\n  transforms: Transform[],\n  name?: string\n): TransformState {\n  name ??= transforms.map(t => t.name).join(', ');\n  logger(`${name}: started`);\n\n  const state: TransformState = { changes: 0 };\n\n  for (const transform of transforms) {\n    transform.run?.(ast, state);\n  }\n\n  const traverseOptions = transforms.flatMap(t => t.visitor?.() ?? []);\n  if (traverseOptions.length > 0) {\n    const visitor = visitors.merge(traverseOptions);\n    // @ts-expect-error regression from https://github.com/babel/babel/pull/15702\n    visitor.noScope = traverseOptions.every(t => t.noScope);\n    traverse(ast, visitor, undefined, state);\n  }\n\n  logger(`${name}: finished with ${state.changes} changes`);\n\n  return state;\n}\n\nexport interface TransformState {\n  changes: number;\n}\n\nexport interface Transform<TOptions = unknown> {\n  name: string;\n  tags: Tag[];\n  run?: (ast: Node, state: TransformState, options?: TOptions) => void;\n  visitor?: (options?: TOptions) => TraverseOptions<TransformState>;\n}\n\nexport interface AsyncTransform<TOptions = unknown>\n  extends Transform<TOptions> {\n  run?: (ast: Node, state: TransformState, options?: TOptions) => Promise<void>;\n}\n\nexport type Tag = 'safe' | 'unsafe';\n", "import * as t from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport { Transform } from '.';\n\nexport default {\n  name: 'mergeStrings',\n  tags: ['safe'],\n  visitor() {\n    const left = m.capture(m.stringLiteral(m.anyString()));\n    const right = m.capture(m.stringLiteral(m.anyString()));\n\n    const matcher = m.binaryExpression('+', left, right);\n    const nestedMatcher = m.binaryExpression(\n      '+',\n      m.binaryExpression('+', m.anything(), left),\n      right\n    );\n\n    return {\n      BinaryExpression: {\n        exit(path) {\n          if (matcher.match(path.node)) {\n            // \"a\" + \"b\" -> \"ab\"\n            path.replaceWith(\n              t.stringLiteral(left.current!.value + right.current!.value)\n            );\n            this.changes++;\n          }\n        },\n      },\n      StringLiteral: {\n        exit(path) {\n          if (nestedMatcher.match(path.parent)) {\n            // (a + \"b\") + \"c\" -> a + \"bc\"\n            //  left ^      ^ right (path)\n            left.current!.value += right.current!.value;\n            path.remove();\n            this.changes++;\n          }\n        },\n      },\n\n      noScope: true,\n    };\n  },\n} satisfies Transform;\n", "import { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport { callExpression } from '@codemod/matchers';\nimport {\n  constMemberExpression,\n  findParent,\n  infiniteLoop,\n} from '../utils/matcher';\nimport { StringArray } from './stringArray';\n\nexport type ArrayRotator = NodePath<t.ExpressionStatement>;\n\n/**\n * Structure:\n * ```\n * iife (>= 2 parameters, called with 0 or 2 arguments)\n *  2 variable declarations (array and decoder)\n *  endless loop:\n *   try:\n *    if/break/parseInt/array.push(array.shift())\n *   catch:\n *    array.push(array.shift())\n * ```\n */\nexport function findArrayRotator(\n  stringArray: StringArray\n): ArrayRotator | undefined {\n  // e.g. 'array'\n  const arrayIdentifier = m.capture(m.identifier());\n\n  // e.g. array.push(array.shift())\n  const pushShift = m.callExpression(\n    constMemberExpression(arrayIdentifier, 'push'),\n    [\n      m.callExpression(\n        constMemberExpression(m.fromCapture(arrayIdentifier), 'shift')\n      ),\n    ]\n  );\n\n  const callMatcher = m.callExpression(\n    m.functionExpression(\n      null,\n      m.anything(),\n      m.blockStatement(\n        m.anyList(\n          m.zeroOrMore(),\n          infiniteLoop(\n            m.matcher(node => {\n              return (\n                m\n                  .containerOf(callExpression(m.identifier('parseInt')))\n                  .match(node) &&\n                m\n                  .blockStatement([\n                    m.tryStatement(\n                      m.containerOf(pushShift),\n                      m.containerOf(pushShift)\n                    ),\n                  ])\n                  .match(node)\n              );\n            })\n          )\n        )\n      )\n    )\n  );\n\n  const matcher = m.expressionStatement(\n    m.or(callMatcher, m.unaryExpression('!', callMatcher))\n  );\n\n  for (const ref of stringArray.references) {\n    const rotator = findParent(ref, matcher);\n    if (rotator) {\n      return rotator;\n    }\n  }\n}\n", "import { Binding, NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport * as m from '@codemod/matchers';\n\nexport function infiniteLoop(\n  body?: m.Matcher<t.Statement>\n): m.Matcher<t.ForStatement | t.WhileStatement> {\n  return m.or(\n    m.forStatement(undefined, null, undefined, body),\n    m.forStatement(undefined, truthyMatcher, undefined, body),\n    m.whileStatement(truthyMatcher, body)\n  );\n}\n\nexport function constKey(\n  name?: string | m.Matcher<string>\n): m.Matcher<t.Identifier | t.StringLiteral> {\n  return m.or(m.identifier(name), m.stringLiteral(name));\n}\n\nexport function constObjectProperty(\n  key?: string | m.Matcher<string>,\n  value?: m.Matcher<t.Expression>\n): m.Matcher<t.ObjectProperty> {\n  return m.or(\n    m.objectProperty(m.identifier(key), value, false),\n    m.objectProperty(m.stringLiteral(key), value, true)\n  );\n}\n\nexport function matchIife(\n  body?: m.Matcher<t.Statement[]> | m.Matcher<t.Statement>[]\n): m.Matcher<t.CallExpression> {\n  return m.callExpression(\n    m.functionExpression(null, [], body ? m.blockStatement(body) : undefined),\n    []\n  );\n}\n\nexport const iife = matchIife();\nexport const emptyIife = matchIife([]);\n\n/**\n * Matches both identifier properties and string literal computed properties\n */\nexport function constMemberExpression(\n  object: string | m.Matcher<t.Expression>,\n  property?: string | m.Matcher<string>\n): m.Matcher<t.MemberExpression> {\n  if (typeof object === 'string') object = m.identifier(object);\n  return m.or(\n    m.memberExpression(object, m.identifier(property), false),\n    m.memberExpression(object, m.stringLiteral(property), true)\n  );\n}\n\nexport const trueMatcher = m.or(\n  m.booleanLiteral(true),\n  m.unaryExpression('!', m.numericLiteral(0)),\n  m.unaryExpression('!', m.unaryExpression('!', m.numericLiteral(1))),\n  m.unaryExpression('!', m.unaryExpression('!', m.arrayExpression([])))\n);\n\nexport const falseMatcher = m.or(\n  m.booleanLiteral(false),\n  m.unaryExpression('!', m.arrayExpression([]))\n);\n\nexport const truthyMatcher = m.or(trueMatcher, m.arrayExpression([]));\n\n/**\n * Starting at the parent path of the current `NodePath` and going up the\n * tree, return the first `NodePath` that causes the provided `matcher`\n * to return true, or `null` if the `matcher` never returns true.\n */\nexport function findParent<T extends t.Node>(\n  path: NodePath,\n  matcher: m.Matcher<T>\n): NodePath<T> | null {\n  return path.findParent(path =>\n    matcher.match(path.node)\n  ) as NodePath<T> | null;\n}\n\n/**\n * Starting at current `NodePath` and going up the tree, return the first\n * `NodePath` that causes the provided `matcher` to return true,\n * or `null` if the `matcher` never returns true.\n */\nexport function findPath<T extends t.Node>(\n  path: NodePath,\n  matcher: m.Matcher<T>\n): NodePath<T> | null {\n  return path.find(path => matcher.match(path.node)) as NodePath<T> | null;\n}\n\n/**\n * Function expression matcher that captures the parameters\n * and allows them to be referenced in the body.\n */\nexport function createFunctionMatcher(\n  params: number,\n  body: (\n    ...captures: m.Matcher<t.Identifier>[]\n  ) => m.Matcher<t.Statement[]> | m.Matcher<t.Statement>[]\n): m.Matcher<t.FunctionExpression> {\n  const captures = Array.from({ length: params }, () =>\n    m.capture(m.anyString())\n  );\n\n  return m.functionExpression(\n    undefined,\n    captures.map(m.identifier),\n    m.blockStatement(body(...captures.map(c => m.identifier(m.fromCapture(c)))))\n  );\n}\n\n/**\n * Returns true if every reference is a member expression whose value is read\n */\nexport function isReadonlyObject(\n  binding: Binding,\n  memberAccess: m.Matcher<t.MemberExpression>\n): boolean {\n  // Workaround because sometimes babel treats the VariableDeclarator/binding itself as a violation\n  if (!binding.constant && binding.constantViolations[0] !== binding.path)\n    return false;\n\n  return binding.referencePaths.every(\n    path =>\n      // obj.property\n      memberAccess.match(path.parent) &&\n      // obj.property = 1\n      !path.parentPath?.parentPath?.isAssignmentExpression({\n        left: path.parent,\n      }) &&\n      // obj.property++\n      !path.parentPath?.parentPath?.isUpdateExpression({\n        argument: path.parent,\n      }) &&\n      // delete obj.property\n      !path.parentPath?.parentPath?.isUnaryExpression({\n        argument: path.parent,\n        operator: 'delete',\n      }) &&\n      // [obj.property] = [{}] or ({ property: obj.property } = {})\n      !path.findParent(\n        parentPath =>\n          parentPath.isArrayPattern() || parentPath.isObjectPattern()\n      )\n  );\n}\n", "import traverse, { Binding, NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport { FunctionExpression } from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport { Transform } from '../transforms';\nimport mergeStrings from '../transforms/mergeStrings';\nimport { getPropName } from '../utils/ast';\nimport { inlineCfFunction } from '../utils/inline';\nimport {\n  constKey,\n  constMemberExpression,\n  createFunctionMatcher,\n  findParent,\n  isReadonlyObject,\n} from '../utils/matcher';\nimport { renameFast } from '../utils/rename';\n\n/**\n * Explanation: https://excalidraw.com/#json=0vehUdrfSS635CNPEQBXl,hDOd-UO9ETfSDWT9MxVX-A\n */\n\nexport default {\n  name: 'controlFlowObject',\n  tags: ['safe'],\n  visitor() {\n    const varId = m.capture(m.identifier());\n    const propertyName = m.matcher<string>(name => /^[a-z]{5}$/i.test(name));\n    const propertyKey = constKey(propertyName);\n    const property = m.or(\n      // E.g. \"6|0|4|3|1|5|2\"\n      m.stringLiteral(),\n      // E.g. function (a, b) { return a + b }\n      createFunctionMatcher(2, (left, right) => [\n        m.returnStatement(\n          m.or(\n            m.binaryExpression(undefined, left, right),\n            m.logicalExpression(undefined, left, right)\n          )\n        ),\n      ]),\n      // E.g. function (a, b, c) { return a(b, c) } with an arbitrary number of arguments\n      m.matcher<FunctionExpression>(node => {\n        return (\n          t.isFunctionExpression(node) &&\n          createFunctionMatcher(node.params.length, (...params) => [\n            m.returnStatement(m.callExpression(params[0], params.slice(1))),\n          ]).match(node)\n        );\n      })\n    );\n    // E.g. \"rLxJs\": \"6|0|4|3|1|5|2\"\n    const objectProperties = m.capture(\n      m.arrayOf(m.objectProperty(propertyKey, property))\n    );\n    const aliasId = m.capture(m.identifier());\n    const aliasVar = m.variableDeclarator(aliasId, m.fromCapture(varId));\n    // E.g. \"rLxJs\"\n    const assignedKey = m.capture(propertyName);\n    // E.g. \"6|0|4|3|1|5|2\"\n    const assignedValue = m.capture(property);\n    // E.g. obj.rLxJs = \"6|0|4|3|1|5|2\"\n    const assignment = m.expressionStatement(\n      m.assignmentExpression(\n        '=',\n        constMemberExpression(m.fromCapture(varId), assignedKey),\n        assignedValue\n      )\n    );\n    // E.g. obj.rLxJs\n    const memberAccess = constMemberExpression(\n      m.or(m.fromCapture(varId), m.fromCapture(aliasId)),\n      propertyName\n    );\n    const varMatcher = m.variableDeclarator(\n      varId,\n      m.capture(m.objectExpression(objectProperties))\n    );\n\n    function isConstantBinding(binding: Binding) {\n      // Workaround because sometimes babel treats the VariableDeclarator/binding itself as a violation\n      return binding.constant || binding.constantViolations[0] === binding.path;\n    }\n\n    function transform(path: NodePath<t.VariableDeclarator>) {\n      let changes = 0;\n      if (varMatcher.match(path.node)) {\n        // Verify all references to make sure they match how the obfuscator\n        // would have generated the code (no reassignments, etc.)\n        const binding = path.scope.getBinding(varId.current!.name);\n        if (!binding) return changes;\n        if (!isConstantBinding(binding)) return changes;\n        if (objectProperties.current!.length === 0)\n          transformObjectKeys(binding);\n        if (!isReadonlyObject(binding, memberAccess)) return changes;\n\n        const props = new Map(\n          objectProperties.current!.map(p => [\n            getPropName(p.key),\n            p.value as t.FunctionExpression | t.StringLiteral,\n          ])\n        );\n        if (!props.size) return changes;\n\n        const oldRefs = [...binding.referencePaths];\n\n        // Have to loop backwards because we might replace a node that\n        // contains another reference to the binding (https://github.com/babel/babel/issues/12943)\n        [...binding.referencePaths].reverse().forEach(ref => {\n          const memberPath = ref.parentPath as NodePath<t.MemberExpression>;\n          const propName = getPropName(memberPath.node.property)!;\n          const value = props.get(propName)!;\n\n          if (t.isStringLiteral(value)) {\n            memberPath.replaceWith(value);\n          } else {\n            inlineCfFunction(\n              value,\n              memberPath.parentPath as NodePath<t.CallExpression>\n            );\n          }\n          changes++;\n        });\n\n        oldRefs.forEach(ref => {\n          const varDeclarator = findParent(ref, m.variableDeclarator());\n          if (varDeclarator) changes += transform(varDeclarator);\n        });\n\n        path.remove();\n        changes++;\n      }\n      return changes;\n    }\n\n    /**\n     * When the `Transform Object Keys` option is enabled, the obfuscator generates an empty\n     * object, assigns the properties later and adds an alias variable to the object.\n     * This function undoes that by converting the assignments to inline object properties.\n     */\n    function transformObjectKeys(objBinding: Binding) {\n      const refs = objBinding.referencePaths;\n\n      if (refs.length < 2) return;\n      if (!aliasVar.match(refs.at(-1)?.parent)) return;\n\n      const assignments: NodePath[] = [];\n\n      for (let i = 0; i < refs.length - 1; i++) {\n        const expressionStatement = refs[i].parentPath?.parentPath?.parentPath;\n        // Example: _0x29d709[\"kHAOU\"] = \"5|1|2\" + \"|4|3|\" + \"0|6\";\n        traverse(expressionStatement!.node, mergeStrings.visitor(), undefined, {\n          changes: 0,\n        });\n        if (!assignment.match(expressionStatement?.node)) return;\n\n        assignments.push(expressionStatement!);\n        objectProperties.current!.push(\n          t.objectProperty(\n            t.identifier(assignedKey.current!),\n            assignedValue.current!\n          )\n        );\n      }\n\n      const aliasBinding = objBinding.scope.getBinding(aliasId.current!.name)!;\n      if (!isReadonlyObject(aliasBinding, memberAccess)) return;\n\n      objBinding.referencePaths = aliasBinding.referencePaths;\n      objBinding.references = aliasBinding.references;\n\n      renameFast(aliasBinding, objBinding.identifier.name);\n\n      assignments.forEach(p => p.remove());\n      aliasBinding.path.remove();\n    }\n\n    return {\n      VariableDeclarator: {\n        exit(path) {\n          this.changes += transform(path);\n        },\n      },\n      noScope: true,\n    };\n  },\n} satisfies Transform;\n", "import generate from '@babel/generator';\nimport * as t from '@babel/types';\n\nexport function codePreview(node: t.Node): string {\n  const { code } = generate(node, {\n    minified: true,\n    shouldPrintComment: () => false,\n  });\n  if (code.length > 100) {\n    return code.slice(0, 70) + ' \u2026 ' + code.slice(-30);\n  }\n  return code;\n}\n\nexport function getPropName(node: t.Node): string | undefined {\n  if (t.isIdentifier(node)) {\n    return node.name;\n  }\n  if (t.isStringLiteral(node)) {\n    return node.value;\n  }\n  if (t.isNumericLiteral(node)) {\n    return node.value.toString();\n  }\n}\n", "import traverse, { Binding, NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport { findParent } from './matcher';\n\n/**\n * Make sure the array is immutable and references are valid before using!\n *\n * Example:\n * `const arr = [\"foo\", \"bar\"]; console.log(arr[0]);` -> `console.log(\"foo\");`\n */\nexport function inlineArrayElements(\n  array: t.ArrayExpression,\n  references: NodePath[]\n): void {\n  for (const reference of references) {\n    const memberPath = reference.parentPath! as NodePath<t.MemberExpression>;\n    const property = memberPath.node.property as t.NumericLiteral;\n    const index = property.value;\n    const replacement = array.elements[index]!;\n    memberPath.replaceWith(replacement);\n  }\n}\n\n/**\n * Inline function used in control flow flattening (that only returns an expression)\n * Example:\n * fn: `function (a, b) { return a(b) }`\n * caller: `fn(a, 1)`\n * ->\n * `a(1)`\n */\nexport function inlineCfFunction(\n  fn: t.FunctionExpression,\n  caller: NodePath<t.CallExpression>\n): void {\n  const returnedValue = (fn.body.body[0] as t.ReturnStatement).argument!;\n  const clone = t.cloneNode(returnedValue, true);\n\n  // Inline all arguments\n  traverse(clone, {\n    Identifier(path) {\n      const paramIndex = fn.params.findIndex(\n        p => (p as t.Identifier).name === path.node.name\n      );\n      if (paramIndex !== -1) {\n        path.replaceWith(caller.node.arguments[paramIndex]);\n        path.skip();\n      }\n    },\n    noScope: true,\n  });\n\n  caller.replaceWith(clone);\n}\n\n/**\n * Example:\n * `function alias(a, b) { return decode(b - 938, a); alias(1071, 1077);`\n * ->\n * `decode(1077 - 938, 1071)`\n */\nexport function inlineFunctionAliases(binding: Binding): { changes: number } {\n  const state = { changes: 0 };\n  const refs = [...binding.referencePaths];\n  for (const ref of refs) {\n    // TODO: can also be a function assigned to a variable\n    const fn = findParent(ref, m.functionDeclaration());\n\n    // E.g. alias\n    const fnName = m.capture(m.anyString());\n    // E.g. decode(b - 938, a)\n    const returnedCall = m.capture(\n      m.callExpression(\n        m.identifier(binding.identifier.name),\n        m.anyList(m.slice({ min: 2 }))\n      )\n    );\n    const matcher = m.functionDeclaration(\n      m.identifier(fnName),\n      m.anyList(m.slice({ min: 2 })),\n      m.blockStatement([m.returnStatement(returnedCall)])\n    );\n\n    if (fn && matcher.match(fn.node)) {\n      // Avoid false positives of functions that return a string\n      // It's only a wrapper if the function's params are used in the decode call\n      const paramUsedInDecodeCall = fn.node.params.some(param => {\n        const binding = fn.scope.getBinding((param as t.Identifier).name);\n        return binding?.referencePaths.some(ref =>\n          ref.findParent(p => p.node === returnedCall.current)\n        );\n      });\n      if (!paramUsedInDecodeCall) continue;\n\n      const fnBinding = fn.scope.parent.getBinding(fnName.current!);\n      if (!fnBinding) continue;\n      // Check all further aliases (`function alias2(a, b) { return alias(a - 1, b + 3); }`)\n      const fnRefs = fnBinding.referencePaths;\n      refs.push(...fnRefs);\n\n      // E.g. [alias(1071, 1077), alias(1, 2)]\n      const callRefs = fnRefs\n        .filter(\n          ref =>\n            t.isCallExpression(ref.parent) &&\n            t.isIdentifier(ref.parent.callee, { name: fnName.current! })\n        )\n        .map(ref => ref.parentPath!) as NodePath<t.CallExpression>[];\n\n      for (const callRef of callRefs) {\n        const fnClone = t.cloneNode(fn.node, true);\n\n        // Inline all arguments\n        traverse(fnClone.body, {\n          Identifier(path) {\n            const paramIndex = fnClone.params.findIndex(\n              p => (p as t.Identifier).name === path.node.name\n            );\n            if (paramIndex !== -1) {\n              path.replaceWith(callRef.node.arguments[paramIndex]);\n              path.skip();\n            }\n          },\n          noScope: true,\n        });\n\n        // Replace the alias call itself with the return value\n        callRef.replaceWith(\n          (fnClone.body.body[0] as t.ReturnStatement).argument!\n        );\n        state.changes++;\n      }\n\n      fn.remove();\n      state.changes++;\n    }\n  }\n\n  // Have to crawl again because renaming messed up the references\n  binding.scope.crawl();\n  return state;\n}\n\n/**\n * Recursively renames all references to the binding.\n * Make sure the binding name isn't shadowed anywhere!\n *\n * Example: `var alias = decoder; alias(1);` -> `decoder(1);`\n */\n\nexport function inlineVariableAliases(\n  binding: Binding,\n  targetName = binding.identifier.name\n): { changes: number } {\n  const state = { changes: 0 };\n  const refs = [...binding.referencePaths];\n  const varName = m.capture(m.anyString());\n  const matcher = m.or(\n    m.variableDeclarator(\n      m.identifier(varName),\n      m.identifier(binding.identifier.name)\n    ),\n    m.assignmentExpression(\n      '=',\n      m.identifier(varName),\n      m.identifier(binding.identifier.name)\n    )\n  );\n\n  for (const ref of refs) {\n    if (matcher.match(ref.parent)) {\n      const varScope = ref.scope;\n      const varBinding = varScope.getBinding(varName.current!);\n      if (!varBinding) continue;\n\n      // Check all further aliases (`var alias2 = alias;`)\n      state.changes += inlineVariableAliases(varBinding, targetName).changes;\n\n      if (ref.parentPath?.isAssignmentExpression()) {\n        // Remove `var alias;` when the assignment happens separately\n        varBinding.path.remove();\n\n        if (t.isExpressionStatement(ref.parentPath.parent)) {\n          // Remove `alias = decoder;`\n          ref.parentPath.remove();\n        } else {\n          // Replace `(alias = decoder)(1);` with `decoder(1);`\n          ref.parentPath.replaceWith(ref.parentPath.node.right);\n        }\n      } else if (ref.parentPath?.isVariableDeclarator()) {\n        // Remove `alias = decoder;` of declarator\n        ref.parentPath.remove();\n      }\n      state.changes++;\n    } else {\n      // Rename the reference\n      ref.replaceWith(t.identifier(targetName));\n      state.changes++;\n    }\n  }\n\n  return state;\n}\n", "import traverse, { Binding, NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport assert from 'assert';\nimport { codePreview } from './ast';\n\nexport function renameFast(binding: Binding, newName: string): void {\n  binding.referencePaths.forEach(ref => {\n    assert(\n      ref.isIdentifier(),\n      `Unexpected reference (${ref.type}): ${codePreview(ref.node)}`\n    );\n    // To avoid conflicts with other bindings of the same name\n    if (ref.scope.hasBinding(newName)) ref.scope.rename(newName);\n    ref.node.name = newName;\n  });\n\n  // Also update assignments\n  const patternMatcher = m.assignmentExpression(\n    '=',\n    m.or(m.arrayPattern(), m.objectPattern())\n  );\n  binding.constantViolations.forEach(ref => {\n    // To avoid conflicts with other bindings of the same name\n    if (ref.scope.hasBinding(newName)) ref.scope.rename(newName);\n\n    if (ref.isAssignmentExpression() && t.isIdentifier(ref.node.left)) {\n      ref.node.left.name = newName;\n    } else if (ref.isUpdateExpression() && t.isIdentifier(ref.node.argument)) {\n      ref.node.argument.name = newName;\n    } else if (ref.isVariableDeclarator() && t.isIdentifier(ref.node.id)) {\n      ref.node.id.name = newName;\n    } else if (ref.isFor() || patternMatcher.match(ref.node)) {\n      traverse(ref.node, {\n        Identifier(path) {\n          if (path.scope !== ref.scope) return path.skip();\n          if (path.node.name === binding.identifier.name) {\n            path.node.name = newName;\n          }\n        },\n        noScope: true,\n      });\n    } else {\n      throw new Error(\n        `Unexpected constant violation (${ref.type}): ${codePreview(ref.node)}`\n      );\n    }\n  });\n\n  binding.scope.removeOwnBinding(binding.identifier.name);\n  binding.scope.bindings[newName] = binding;\n  binding.identifier.name = newName;\n}\n\nexport function renameParameters(\n  path: NodePath<t.Function>,\n  newNames: string[]\n): void {\n  const params = path.node.params as t.Identifier[];\n  for (let i = 0; i < Math.min(params.length, newNames.length); i++) {\n    const binding = path.scope.getBinding(params[i].name)!;\n    renameFast(binding, newNames[i]);\n  }\n}\n", "import * as t from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport { Transform } from '../transforms';\nimport { constMemberExpression, infiniteLoop } from '../utils/matcher';\n\nexport default {\n  name: 'controlFlowSwitch',\n  tags: ['safe'],\n  visitor() {\n    const sequenceName = m.capture(m.identifier());\n    const sequenceString = m.capture(\n      m.matcher<string>(s => /^\\d+(\\|\\d+)*$/.test(s))\n    );\n    const iterator = m.capture(m.identifier());\n\n    const cases = m.capture(\n      m.arrayOf(\n        m.switchCase(\n          m.stringLiteral(m.matcher(s => /^\\d+$/.test(s))),\n          m.anyList(\n            m.zeroOrMore(),\n            m.or(m.continueStatement(), m.returnStatement())\n          )\n        )\n      )\n    );\n\n    const matcher = m.blockStatement(\n      m.anyList<t.Statement>(\n        // E.g. const sequence = \"2|4|3|0|1\".split(\"|\")\n        m.variableDeclaration(undefined, [\n          m.variableDeclarator(\n            sequenceName,\n            m.callExpression(\n              constMemberExpression(m.stringLiteral(sequenceString), 'split'),\n              [m.stringLiteral('|')]\n            )\n          ),\n        ]),\n        // E.g. let iterator = 0 or -0x1a70 + 0x93d + 0x275 * 0x7\n        m.variableDeclaration(undefined, [m.variableDeclarator(iterator)]),\n        infiniteLoop(\n          m.blockStatement([\n            m.switchStatement(\n              // E.g. switch (sequence[iterator++]) {\n              m.memberExpression(\n                m.fromCapture(sequenceName),\n                m.updateExpression('++', m.fromCapture(iterator)),\n                true\n              ),\n              cases\n            ),\n            m.breakStatement(),\n          ])\n        ),\n        m.zeroOrMore()\n      )\n    );\n\n    return {\n      BlockStatement: {\n        exit(path) {\n          if (!matcher.match(path.node)) return;\n\n          const caseStatements = new Map(\n            cases.current!.map(c => [\n              (c.test as t.StringLiteral).value,\n              t.isContinueStatement(c.consequent.at(-1))\n                ? c.consequent.slice(0, -1)\n                : c.consequent,\n            ])\n          );\n\n          const sequence = sequenceString.current!.split('|');\n          const newStatements = sequence.flatMap(s => caseStatements.get(s)!);\n\n          path.node.body.splice(0, 3, ...newStatements);\n          this.changes += newStatements.length + 3;\n        },\n      },\n      noScope: true,\n    };\n  },\n} satisfies Transform;\n", "import { NodePath, Scope } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport { Transform } from '../transforms';\nimport { renameFast } from '../utils/rename';\n\nexport default {\n  name: 'deadCode',\n  tags: ['unsafe'],\n  visitor() {\n    const stringComparison = m.binaryExpression(\n      m.or('===', '==', '!==', '!='),\n      m.stringLiteral(),\n      m.stringLiteral()\n    );\n    const testMatcher = m.or(\n      stringComparison,\n      m.unaryExpression('!', stringComparison)\n    );\n\n    return {\n      'IfStatement|ConditionalExpression': {\n        exit(_path) {\n          const path = _path as NodePath<\n            t.IfStatement | t.ConditionalExpression\n          >;\n\n          if (!testMatcher.match(path.node.test)) return;\n\n          const { scope } = path;\n          // If statements can contain variables that shadow variables in the parent scope.\n          // Since the block scope is merged with the parent scope, we need to rename those\n          // variables to avoid duplicate declarations.\n          function renameShadowedVariables(localScope: Scope) {\n            if (localScope === scope) return;\n            for (const name in localScope.bindings) {\n              if (scope.hasBinding(name)) {\n                renameFast(localScope.bindings[name], scope.generateUid(name));\n              }\n            }\n          }\n\n          if (path.get('test').evaluateTruthy()) {\n            renameShadowedVariables(path.get('consequent').scope);\n            replace(path, path.node.consequent);\n          } else if (path.node.alternate) {\n            renameShadowedVariables(path.get('alternate').scope);\n            replace(path, path.node.alternate);\n          } else {\n            path.remove();\n          }\n\n          this.changes++;\n        },\n      },\n      noScope: true,\n    };\n  },\n} satisfies Transform;\n\nfunction replace(path: NodePath, node: t.Node) {\n  if (t.isBlockStatement(node)) {\n    path.replaceWithMultiple(node.body);\n  } else {\n    path.replaceWith(node);\n  }\n}\n", "import { expression } from '@babel/template';\nimport { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport { findParent } from '../utils/matcher';\nimport { renameFast } from '../utils/rename';\nimport { StringArray } from './stringArray';\n\n/**\n * A function that is called with >= 1 numeric/string arguments\n * and returns a string from the string array. It may also decode\n * the string with Base64 or RC4.\n */\nexport class Decoder {\n  name: string;\n  path: NodePath<t.FunctionDeclaration>;\n\n  constructor(name: string, path: NodePath<t.FunctionDeclaration>) {\n    this.name = name;\n    this.path = path;\n  }\n\n  collectCalls(): NodePath<t.CallExpression>[] {\n    const calls: NodePath<t.CallExpression>[] = [];\n\n    const argumentMatcher: m.Matcher<t.Expression> = m.or(\n      m.binaryExpression(\n        m.anything(),\n        m.matcher(node => argumentMatcher.match(node)),\n        m.matcher(node => argumentMatcher.match(node))\n      ),\n      m.unaryExpression(\n        '-',\n        m.matcher(node => argumentMatcher.match(node))\n      ),\n      m.numericLiteral(),\n      m.stringLiteral()\n    );\n\n    const call = m.callExpression(\n      m.identifier(this.name),\n      m.arrayOf(argumentMatcher)\n    );\n\n    const conditional = m.capture(m.conditionalExpression());\n    const conditionalCall = m.callExpression(m.identifier(this.name), [\n      conditional,\n    ]);\n\n    const buildExtractedConditional = expression`TEST ? CALLEE(CONSEQUENT) : CALLEE(ALTERNATE)`;\n\n    const binding = this.path.scope.getBinding(this.name)!;\n    for (const ref of binding.referencePaths) {\n      if (conditionalCall.match(ref.parent)) {\n        // decode(test ? 1 : 2) -> test ? decode(1) : decode(2)\n        const [replacement] = ref.parentPath!.replaceWith(\n          buildExtractedConditional({\n            TEST: conditional.current!.test,\n            CALLEE: ref.parent.callee,\n            CONSEQUENT: conditional.current!.consequent,\n            ALTERNATE: conditional.current!.alternate,\n          })\n        );\n        // some of the scope information is somehow lost after replacing\n        replacement.scope.crawl();\n      } else if (call.match(ref.parent)) {\n        calls.push(ref.parentPath as NodePath<t.CallExpression>);\n      }\n    }\n\n    return calls;\n  }\n}\n\n// TODO: can also be a function assigned to a variable\nexport function findDecoders(stringArray: StringArray): Decoder[] {\n  const decoders: Decoder[] = [];\n\n  const functionName = m.capture(m.anyString());\n  const arrayIdentifier = m.capture(m.identifier());\n  const matcher = m.functionDeclaration(\n    m.identifier(functionName),\n    m.anything(),\n    m.blockStatement(\n      m.anyList(\n        // var array = getStringArray();\n        m.variableDeclaration(undefined, [\n          m.variableDeclarator(\n            arrayIdentifier,\n            m.callExpression(m.identifier(stringArray.name))\n          ),\n        ]),\n        m.zeroOrMore(),\n        // var h = array[e]; return h;\n        // or return array[e -= 254];\n        m.containerOf(\n          m.memberExpression(m.fromCapture(arrayIdentifier), undefined, true)\n        ),\n        m.zeroOrMore()\n      )\n    )\n  );\n\n  for (const ref of stringArray.references) {\n    const decoderFn = findParent(ref, matcher);\n\n    if (decoderFn) {\n      const oldName = functionName.current!;\n      const newName = `__DECODE_${decoders.length}__`;\n      const binding = decoderFn.scope.getBinding(oldName)!;\n      renameFast(binding, newName);\n      decoders.push(new Decoder(newName, decoderFn));\n    }\n  }\n\n  return decoders;\n}\n", "import * as t from '@babel/types';\nimport { AsyncTransform } from '../transforms';\nimport { VMDecoder } from './vm';\n\n/**\n * Replaces calls to decoder functions with the decoded string.\n * E.g. `m(199)` -> `'log'`\n */\nexport default {\n  name: 'inlineDecodedStrings',\n  tags: ['unsafe'],\n  async run(ast, state, options) {\n    if (!options) return;\n\n    const calls = options.vm.decoders.flatMap(decoder =>\n      decoder.collectCalls()\n    );\n    const decodedValues = await options.vm.decode(calls);\n\n    for (let i = 0; i < calls.length; i++) {\n      const call = calls[i];\n      const value = decodedValues[i];\n\n      call.replaceWith(t.valueToNode(value));\n      if (typeof value !== 'string')\n        call.addComment('leading', 'webcrack:decode_error');\n    }\n\n    state.changes += calls.length;\n  },\n} satisfies AsyncTransform<{ vm: VMDecoder }>;\n", "import { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport { Transform } from '../transforms';\nimport { inlineFunctionAliases, inlineVariableAliases } from '../utils/inline';\n\n/**\n * Replaces all references to `var alias = decode;` with `decode`\n */\nexport default {\n  name: 'inlineDecoderWrappers',\n  tags: ['unsafe'],\n  run(ast, state, decoder) {\n    if (!decoder?.node.id) return;\n\n    const decoderName = decoder.node.id.name;\n    const decoderBinding = decoder.parentPath.scope.getBinding(decoderName);\n    if (decoderBinding) {\n      state.changes += inlineVariableAliases(decoderBinding).changes;\n      state.changes += inlineFunctionAliases(decoderBinding).changes;\n    }\n  },\n} satisfies Transform<NodePath<t.FunctionDeclaration>>;\n", "import { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport { Transform } from '../transforms';\nimport { getPropName } from '../utils/ast';\nimport {\n  constKey,\n  constMemberExpression,\n  isReadonlyObject,\n} from '../utils/matcher';\n\n/**\n * Inline objects that only have string or numeric literal properties.\n * Used by the \"String Array Calls Transform\" option for moving the\n * decode call arguments into an object.\n * Example:\n * ```js\n * const obj = {\n *   c: 0x2f2,\n *   d: '0x396',\n * };\n * console.log(decode(obj.c, obj.d));\n * ```\n * ->\n * ```js\n * console.log(decode(0x2f2, '0x396'));\n * ```\n */\nexport default {\n  name: 'inlineObjectProps',\n  tags: ['safe'],\n  visitor() {\n    const varId = m.capture(m.identifier());\n    const propertyName = m.matcher<string>(name => /^[\\w]+$/i.test(name));\n    const propertyKey = constKey(propertyName);\n    // E.g. \"_0x51b74a\": 0x80\n    const objectProperties = m.capture(\n      m.arrayOf(\n        m.objectProperty(\n          propertyKey,\n          m.or(m.stringLiteral(), m.numericLiteral())\n        )\n      )\n    );\n    // E.g. obj._0x51b74a\n    const memberAccess = constMemberExpression(\n      m.fromCapture(varId),\n      propertyName\n    );\n    const varMatcher = m.variableDeclarator(\n      varId,\n      m.objectExpression(objectProperties)\n    );\n\n    return {\n      VariableDeclarator(path) {\n        if (!varMatcher.match(path.node)) return;\n        if (objectProperties.current!.length === 0) return;\n\n        const binding = path.scope.getBinding(varId.current!.name);\n        if (!binding || !isReadonlyObject(binding, memberAccess)) return;\n\n        const props = new Map(\n          objectProperties.current!.map(p => [\n            getPropName(p.key),\n            p.value as t.StringLiteral | t.NumericLiteral,\n          ])\n        );\n\n        if (\n          !binding.referencePaths.every(ref => {\n            const memberPath = ref.parentPath as NodePath<t.MemberExpression>;\n            const propName = getPropName(memberPath.node.property)!;\n            return props.has(propName);\n          })\n        )\n          return;\n\n        binding.referencePaths.forEach(ref => {\n          const memberPath = ref.parentPath as NodePath<t.MemberExpression>;\n          const propName = getPropName(memberPath.node.property)!;\n          const value = props.get(propName)!;\n\n          memberPath.replaceWith(value);\n          this.changes++;\n        });\n\n        path.remove();\n        this.changes++;\n      },\n      noScope: true,\n    };\n  },\n} satisfies Transform;\n", "import traverse, { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport { inlineArrayElements } from '../utils/inline';\nimport { isReadonlyObject } from '../utils/matcher';\nimport { renameFast } from '../utils/rename';\n\nexport interface StringArray {\n  path: NodePath<t.FunctionDeclaration>;\n  references: NodePath[];\n  name: string;\n  length: number;\n}\n\nexport function findStringArray(ast: t.Node): StringArray | undefined {\n  let result: StringArray | undefined;\n  const functionName = m.capture(m.anyString());\n  const arrayIdentifier = m.capture(m.identifier());\n  const arrayExpression = m.capture(\n    m.arrayExpression(m.arrayOf(m.stringLiteral()))\n  );\n  // getStringArray = function () { return n; };\n  const functionAssignment = m.assignmentExpression(\n    '=',\n    m.identifier(m.fromCapture(functionName)),\n    m.functionExpression(\n      undefined,\n      [],\n      m.blockStatement([m.returnStatement(m.fromCapture(arrayIdentifier))])\n    )\n  );\n  const variableDeclaration = m.variableDeclaration(undefined, [\n    m.variableDeclarator(arrayIdentifier, arrayExpression),\n  ]);\n  // function getStringArray() { ... }\n  const matcher = m.functionDeclaration(\n    m.identifier(functionName),\n    [],\n    m.or(\n      // var array = [\"hello\", \"world\"];\n      // return (getStringArray = function () { return array; })();\n      m.blockStatement([\n        variableDeclaration,\n        m.returnStatement(m.callExpression(functionAssignment)),\n      ]),\n      // var array = [\"hello\", \"world\"];\n      // getStringArray = function () { return n; });\n      // return getStringArray();\n      m.blockStatement([\n        variableDeclaration,\n        m.expressionStatement(functionAssignment),\n        m.returnStatement(m.callExpression(m.identifier(functionName))),\n      ])\n    )\n  );\n\n  traverse(ast, {\n    // Wrapped string array from later javascript-obfuscator versions\n    FunctionDeclaration(path) {\n      if (matcher.match(path.node)) {\n        const length = arrayExpression.current!.elements.length;\n        const name = functionName.current!;\n        const binding = path.scope.getBinding(name)!;\n        renameFast(binding, '__STRING_ARRAY__');\n\n        result = {\n          path,\n          references: binding.referencePaths,\n          name: '__STRING_ARRAY__',\n          length,\n        };\n        path.stop();\n      }\n    },\n    // Simple string array inlining (only `array[0]`, `array[1]` etc references, no rotating/decoding).\n    // May be used by older or different obfuscators\n    VariableDeclaration(path) {\n      if (!variableDeclaration.match(path.node)) return;\n\n      const length = arrayExpression.current!.elements.length;\n      const binding = path.scope.getBinding(arrayIdentifier.current!.name)!;\n      const memberAccess = m.memberExpression(\n        m.fromCapture(arrayIdentifier),\n        m.numericLiteral(m.matcher(value => value < length))\n      );\n      if (!isReadonlyObject(binding, memberAccess)) return;\n\n      inlineArrayElements(arrayExpression.current!, binding.referencePaths);\n      path.remove();\n    },\n  });\n\n  return result;\n}\n", "import generate from '@babel/generator';\nimport { NodePath } from '@babel/traverse';\nimport { CallExpression } from '@babel/types';\nimport debug from 'debug';\nimport { ArrayRotator } from './arrayRotator';\nimport { Decoder } from './decoder';\nimport { StringArray } from './stringArray';\n\nexport type Sandbox = (code: string) => Promise<unknown>;\n\nexport function createNodeSandbox(): Sandbox {\n  return async (code: string) => {\n    const {\n      default: { Isolate },\n    } = await import('isolated-vm');\n    const isolate = new Isolate();\n    const context = await isolate.createContext();\n    const result = (await context.eval(code, {\n      timeout: 10_000,\n      copy: true,\n      filename: 'file:///obfuscated.js',\n    })) as unknown;\n    context.release();\n    isolate.dispose();\n    return result;\n  };\n}\n\nexport function createBrowserSandbox(): Sandbox {\n  return () => {\n    // TODO: use sandybox (not available in web workers though)\n    throw new Error('Custom Sandbox implementation required.');\n  };\n}\n\nexport class VMDecoder {\n  decoders: Decoder[];\n  private setupCode: string;\n  private sandbox: Sandbox;\n\n  constructor(\n    sandbox: Sandbox,\n    stringArray: StringArray,\n    decoders: Decoder[],\n    rotator?: ArrayRotator\n  ) {\n    this.sandbox = sandbox;\n    this.decoders = decoders;\n\n    // Generate as compact to bypass the self defense\n    // (which tests someFunction.toString against a regex)\n    const generateOptions = {\n      compact: true,\n      shouldPrintComment: () => false,\n    };\n    const stringArrayCode = generate(\n      stringArray.path.node,\n      generateOptions\n    ).code;\n    const rotatorCode = rotator\n      ? generate(rotator.node, generateOptions).code\n      : '';\n    const decoderCode = decoders\n      .map(decoder => generate(decoder.path.node, generateOptions).code)\n      .join(';\\n');\n\n    this.setupCode = [stringArrayCode, rotatorCode, decoderCode].join(';\\n');\n  }\n\n  async decode(calls: NodePath<CallExpression>[]): Promise<unknown[]> {\n    const code = `(() => {\n      ${this.setupCode}\n      return [${calls.join(',')}]\n    })()`;\n\n    try {\n      const result = await this.sandbox(code);\n      return result as unknown[];\n    } catch (err) {\n      debug('webcrack:deobfuscate')('vm code:', code);\n      throw err;\n    }\n  }\n}\n", "import * as m from '@codemod/matchers';\nimport { ifStatement } from '@codemod/matchers';\nimport { Transform } from '../transforms';\nimport { constMemberExpression, findParent, iife } from '../utils/matcher';\n\n// https://github.com/javascript-obfuscator/javascript-obfuscator/blob/d7f73935557b2cd15a2f7cd0b01017d9cddbd015/src/custom-code-helpers/debug-protection/templates/debug-protection-function-interval/DebugProtectionFunctionIntervalTemplate.ts\n\n// https://github.com/javascript-obfuscator/javascript-obfuscator/blob/d7f73935557b2cd15a2f7cd0b01017d9cddbd015/src/custom-code-helpers/debug-protection/templates/debug-protection-function/DebugProtectionFunctionTemplate.ts\n\n// https://github.com/javascript-obfuscator/javascript-obfuscator/blob/d7f73935557b2cd15a2f7cd0b01017d9cddbd015/src/custom-code-helpers/debug-protection/templates/debug-protection-function/DebuggerTemplate.ts\n\n// https://github.com/javascript-obfuscator/javascript-obfuscator/blob/d7f73935557b2cd15a2f7cd0b01017d9cddbd015/src/custom-code-helpers/debug-protection/templates/debug-protection-function/DebuggerTemplateNoEval.ts\n\nexport default {\n  name: 'debugProtection',\n  tags: ['safe'],\n  visitor() {\n    const ret = m.capture(m.identifier());\n    const debugProtectionFunctionName = m.capture(m.anyString());\n    const debuggerProtection = m.capture(m.identifier());\n    const counter = m.capture(m.identifier());\n    const debuggerTemplate = m.ifStatement(\n      undefined,\n      undefined,\n      m.containerOf(\n        m.or(\n          m.debuggerStatement(),\n          m.callExpression(\n            constMemberExpression(m.anyExpression(), 'constructor'),\n            [m.stringLiteral('debugger')]\n          )\n        )\n      )\n    );\n    // that.setInterval(debugProtectionFunctionName, 4000);\n    const intervalCall = m.callExpression(\n      constMemberExpression(m.anyExpression(), 'setInterval'),\n      [\n        m.identifier(m.fromCapture(debugProtectionFunctionName)),\n        m.numericLiteral(),\n      ]\n    );\n\n    // function debugProtectionFunctionName(ret) {\n    const matcher = m.functionDeclaration(\n      m.identifier(debugProtectionFunctionName),\n      [ret],\n      m.blockStatement([\n        // function debuggerProtection (counter) {\n        m.functionDeclaration(\n          debuggerProtection,\n          [counter],\n          m.blockStatement([\n            debuggerTemplate,\n            // debuggerProtection(++counter);\n            m.expressionStatement(\n              m.callExpression(m.fromCapture(debuggerProtection), [\n                m.updateExpression('++', m.fromCapture(counter), true),\n              ])\n            ),\n          ])\n        ),\n        m.tryStatement(\n          m.blockStatement([\n            // if (ret) {\n            ifStatement(\n              m.fromCapture(ret),\n              // return debuggerProtection;\n              m.blockStatement([\n                m.returnStatement(m.fromCapture(debuggerProtection)),\n              ]),\n              // } else { debuggerProtection(0); }\n              m.blockStatement([\n                m.expressionStatement(\n                  m.callExpression(m.fromCapture(debuggerProtection), [\n                    m.numericLiteral(0),\n                  ])\n                ),\n              ])\n            ),\n          ])\n        ),\n      ])\n    );\n\n    return {\n      FunctionDeclaration(path) {\n        if (!matcher.match(path.node)) return;\n\n        const binding = path.scope.getBinding(\n          debugProtectionFunctionName.current!\n        )!;\n\n        binding.referencePaths.forEach(ref => {\n          if (intervalCall.match(ref.parent)) {\n            findParent(ref, iife)?.remove();\n          }\n        });\n\n        path.remove();\n      },\n      noScope: true,\n    };\n  },\n} satisfies Transform;\n", "import { Binding } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport { Transform } from '../transforms';\nimport { constObjectProperty } from '../utils/matcher';\n\n/**\n * Merges object assignments into the object expression.\n * Example:\n * ```js\n * const obj = {};\n * obj.foo = 'bar';\n * ```\n * ->\n * ```js\n * const obj = { foo: 'bar' };\n * ```\n */\nexport default {\n  name: 'mergeObjectAssignments',\n  tags: ['safe'],\n  visitor: () => {\n    const id = m.capture(m.identifier());\n    const object = m.capture(m.objectExpression([]));\n    // Example: const obj = {};\n    const varMatcher = m.variableDeclaration(undefined, [\n      m.variableDeclarator(id, object),\n    ]);\n    const key = m.capture(m.anyExpression());\n    const computed = m.capture<boolean>(m.anything());\n    const value = m.capture(m.anyExpression());\n    // Example: obj.foo = 'bar';\n    const assignmentMatcher = m.expressionStatement(\n      m.assignmentExpression(\n        '=',\n        m.memberExpression(m.fromCapture(id), key, computed),\n        value\n      )\n    );\n\n    return {\n      Program(path) {\n        // No idea why this is needed, crashes otherwise.\n        path.scope.crawl();\n      },\n      VariableDeclaration: {\n        exit(path) {\n          if (!path.inList || !varMatcher.match(path.node)) return;\n\n          const binding = path.scope.getBinding(id.current!.name)!;\n          const container = path.container as t.Statement[];\n          const siblingIndex = (path.key as number) + 1;\n\n          while (siblingIndex < container.length) {\n            const sibling = path.getSibling(siblingIndex);\n            if (\n              !assignmentMatcher.match(sibling.node) ||\n              hasCircularReference(value.current!, binding)\n            )\n              return;\n\n            // { [1]: value, \"foo bar\": value } can be simplified to { 1: value, \"foo bar\": value }\n            const isComputed =\n              computed.current! &&\n              key.current!.type !== 'NumericLiteral' &&\n              key.current!.type !== 'StringLiteral';\n\n            // Example: const obj = { x: 1 }; obj.foo = 'bar'; -> const obj = { x: 1, foo: 'bar' };\n            object.current!.properties.push(\n              t.objectProperty(key.current!, value.current!, isComputed)\n            );\n\n            sibling.remove();\n            binding.dereference();\n            binding.referencePaths.shift();\n\n            // Example: const obj = { foo: 'bar' }; return obj; -> return { foo: 'bar' };\n            if (\n              binding.references === 1 &&\n              inlineableObject.match(object.current)\n            ) {\n              binding.referencePaths[0].replaceWith(object.current);\n              path.remove();\n              this.changes++;\n            }\n          }\n        },\n      },\n    };\n  },\n} satisfies Transform;\n\n/**\n * Used to avoid \"Cannot access 'obj' before initialization\" errors.\n */\nfunction hasCircularReference(node: t.Node, binding: Binding) {\n  return (\n    // obj.foo = obj;\n    binding.referencePaths.some(path => path.find(p => p.node === node)) ||\n    // obj.foo = fn(); where fn could reference the binding or not, for simplicity we assume it does.\n    m.containerOf(m.callExpression()).match(node)\n  );\n}\n\n/**\n * Only literals, arrays and objects are allowed because variable values\n * might be different in the place the object will be inlined.\n */\nconst inlineableObject: m.Matcher<t.Expression> = m.matcher(\n  node =>\n    (t.isLiteral(node) && !t.isTemplateLiteral(node)) ||\n    m.arrayExpression(m.arrayOf(inlineableObject)).match(node) ||\n    m\n      .objectExpression(\n        m.arrayOf(constObjectProperty(m.anything(), inlineableObject))\n      )\n      .match(node)\n);\n", "import { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport { Transform } from '../transforms';\nimport {\n  constMemberExpression,\n  emptyIife,\n  falseMatcher,\n  findParent,\n  matchIife,\n  trueMatcher,\n} from '../utils/matcher';\n\n// SingleCallController: https://github.com/javascript-obfuscator/javascript-obfuscator/blob/d7f73935557b2cd15a2f7cd0b01017d9cddbd015/src/custom-code-helpers/common/templates/SingleCallControllerTemplate.ts\n\n// Works for\n// self defending: https://github.com/javascript-obfuscator/javascript-obfuscator/blob/d7f73935557b2cd15a2f7cd0b01017d9cddbd015/src/custom-code-helpers/self-defending/templates/SelfDefendingTemplate.ts\n// domain lock: https://github.com/javascript-obfuscator/javascript-obfuscator/blob/d7f73935557b2cd15a2f7cd0b01017d9cddbd015/src/custom-code-helpers/domain-lock/templates/DomainLockTemplate.ts\n// console output: https://github.com/javascript-obfuscator/javascript-obfuscator/blob/d7f73935557b2cd15a2f7cd0b01017d9cddbd015/src/custom-code-helpers/console-output/templates/ConsoleOutputDisableTemplate.ts\n// debug protection function call: https://github.com/javascript-obfuscator/javascript-obfuscator/blob/d7f73935557b2cd15a2f7cd0b01017d9cddbd015/src/custom-code-helpers/debug-protection/templates/debug-protection-function-call/DebugProtectionFunctionCallTemplate.ts\n\nexport default {\n  name: 'selfDefending',\n  tags: ['safe'],\n  visitor() {\n    const callController = m.capture(m.anyString());\n    const firstCall = m.capture(m.identifier());\n    const rfn = m.capture(m.identifier());\n    const context = m.capture(m.identifier());\n    const res = m.capture(m.identifier());\n    const fn = m.capture(m.identifier());\n\n    // const callControllerFunctionName = (function() { ... })();\n    const matcher = m.variableDeclarator(\n      m.identifier(callController),\n      matchIife([\n        // let firstCall = true;\n        m.variableDeclaration(undefined, [\n          m.variableDeclarator(firstCall, trueMatcher),\n        ]),\n        // return function (context, fn) {\n        m.returnStatement(\n          m.functionExpression(\n            null,\n            [context, fn],\n            m.blockStatement([\n              m.variableDeclaration(undefined, [\n                // const rfn = firstCall ? function() {\n                m.variableDeclarator(\n                  rfn,\n                  m.conditionalExpression(\n                    m.fromCapture(firstCall),\n                    m.functionExpression(\n                      null,\n                      [],\n                      m.blockStatement([\n                        // if (fn) {\n                        m.ifStatement(\n                          m.fromCapture(fn),\n                          m.blockStatement([\n                            // const res = fn.apply(context, arguments);\n                            m.variableDeclaration(undefined, [\n                              m.variableDeclarator(\n                                res,\n                                m.callExpression(\n                                  constMemberExpression(\n                                    m.fromCapture(fn),\n                                    'apply'\n                                  ),\n                                  [\n                                    m.fromCapture(context),\n                                    m.identifier('arguments'),\n                                  ]\n                                )\n                              ),\n                            ]),\n                            // fn = null;\n                            m.expressionStatement(\n                              m.assignmentExpression(\n                                '=',\n                                m.fromCapture(fn),\n                                m.nullLiteral()\n                              )\n                            ),\n                            // return res;\n                            m.returnStatement(m.fromCapture(res)),\n                          ])\n                        ),\n                      ])\n                    ),\n                    // : function() {}\n                    m.functionExpression(null, [], m.blockStatement([]))\n                  )\n                ),\n              ]),\n              // firstCall = false;\n              m.expressionStatement(\n                m.assignmentExpression(\n                  '=',\n                  m.fromCapture(firstCall),\n                  falseMatcher\n                )\n              ),\n              // return rfn;\n              m.returnStatement(m.fromCapture(rfn)),\n            ])\n          )\n        ),\n      ])\n    );\n\n    return {\n      VariableDeclarator(path) {\n        if (!matcher.match(path.node)) return;\n        const binding = path.scope.getBinding(callController.current!)!;\n        // const callControllerFunctionName = (function() { ... })();\n        //       ^ path/binding\n\n        binding.referencePaths\n          .filter(ref => ref.parent.type === 'CallExpression')\n          .forEach(ref => {\n            if (ref.parentPath?.parent.type === 'CallExpression') {\n              // callControllerFunctionName(this, function () { ... })();\n              // ^ ref\n              ref.parentPath.parentPath?.remove();\n            } else {\n              // const selfDefendingFunctionName = callControllerFunctionName(this, function () {\n              // selfDefendingFunctionName();      ^ ref\n              removeSelfDefendingRefs(ref as NodePath<t.Identifier>);\n            }\n\n            // leftover (function () {})() from debug protection function call\n            findParent(ref, emptyIife)?.remove();\n\n            this.changes++;\n          });\n\n        path.remove();\n        this.changes++;\n      },\n      noScope: true,\n    };\n  },\n} satisfies Transform;\n\nfunction removeSelfDefendingRefs(path: NodePath<t.Identifier>) {\n  const varName = m.capture(m.anyString());\n  const varMatcher = m.variableDeclarator(\n    m.identifier(varName),\n    m.callExpression(m.identifier(path.node.name))\n  );\n  const callMatcher = m.expressionStatement(\n    m.callExpression(m.identifier(m.fromCapture(varName)), [])\n  );\n  const varDecl = findParent(path, varMatcher);\n\n  if (varDecl) {\n    const binding = varDecl.scope.getBinding(varName.current!);\n\n    binding?.referencePaths.forEach(ref => {\n      if (callMatcher.match(ref.parentPath?.parent))\n        ref.parentPath?.parentPath?.remove();\n    });\n    varDecl.remove();\n  }\n}\n", "import traverse, { Visitor, visitors } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport debug from 'debug';\nimport { TransformState } from '../transforms';\nimport { unpackBrowserify } from './browserify';\nimport { Bundle } from './bundle';\nimport { unpackWebpack } from './webpack';\n\nexport function unpackBundle(\n  ast: t.Node,\n  mappings: Record<string, m.Matcher<unknown>> = {}\n): Bundle | undefined {\n  const options: { bundle: Bundle | undefined } = { bundle: undefined };\n  const traverseOptions: Visitor<TransformState>[] = [\n    unpackWebpack.visitor(options),\n    unpackBrowserify.visitor(options),\n  ];\n  const visitor = visitors.merge(traverseOptions);\n  // @ts-expect-error regression from https://github.com/babel/babel/pull/15702\n  visitor.noScope = traverseOptions.every(v => v.noScope);\n  traverse(ast, visitor, undefined, { changes: 0 });\n  if (options.bundle) {\n    options.bundle.applyMappings(mappings);\n    options.bundle.applyTransforms();\n    debug('webcrack:unpack')('Bundle:', options.bundle.type);\n  }\n  return options.bundle;\n}\n", "import { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport { Transform } from '../../transforms';\nimport { getPropName } from '../../utils/ast';\nimport { constKey, matchIife } from '../../utils/matcher';\nimport { resolveDependencyTree } from '../../utils/path';\nimport { renameParameters } from '../../utils/rename';\nimport { Bundle } from '../bundle';\nimport { BrowserifyBundle } from './bundle';\nimport { BrowserifyModule } from './module';\n\nexport const unpackBrowserify = {\n  name: 'unpack-browserify',\n  tags: ['unsafe'],\n  visitor(options) {\n    const modules = new Map<string, BrowserifyModule>();\n\n    const files = m.capture(\n      m.arrayOf(\n        m.objectProperty(\n          m.numericLiteral(),\n          m.arrayExpression([\n            // function(require, module, exports) {...}\n            m.functionExpression(),\n            // dependencies: { './add': 1, 'lib': 3 }\n            m.objectExpression(\n              m.arrayOf(\n                m.objectProperty(\n                  constKey(),\n                  m.or(\n                    m.numericLiteral(),\n                    m.identifier('undefined'),\n                    m.stringLiteral()\n                  )\n                )\n              )\n            ),\n          ])\n        )\n      )\n    );\n    const entryIdMatcher = m.capture(m.numericLiteral());\n\n    const matcher = m.callExpression(\n      m.or(\n        // (function (files, cache, entryIds) {...})(...)\n        m.functionExpression(undefined, [\n          m.identifier(),\n          m.identifier(),\n          m.identifier(),\n        ]),\n        // (function () { function init(files, cache, entryIds) {...} return init; })()(...)\n        matchIife([\n          m.functionDeclaration(undefined, [\n            m.identifier(),\n            m.identifier(),\n            m.identifier(),\n          ]),\n          m.returnStatement(m.identifier()),\n        ])\n      ),\n      [\n        m.objectExpression(files),\n        m.objectExpression(),\n        m.arrayExpression([entryIdMatcher]),\n      ]\n    );\n\n    return {\n      CallExpression(path) {\n        if (!matcher.match(path.node)) return;\n        path.stop();\n\n        const entryId = entryIdMatcher.current!.value.toString();\n\n        const modulesPath = path.get(\n          files.currentKeys!.join('.')\n        ) as NodePath<t.ObjectProperty>[];\n\n        const dependencyTree: Record<string, Record<string, string>> = {};\n\n        for (const moduleWrapper of modulesPath) {\n          const id = (\n            moduleWrapper.node.key as t.NumericLiteral\n          ).value.toString();\n          const fn = moduleWrapper.get(\n            'value.elements.0'\n          ) as NodePath<t.FunctionExpression>;\n\n          const dependencies: Record<string, string> = (dependencyTree[id] =\n            {});\n          const dependencyProperties = (\n            moduleWrapper.get(\n              'value.elements.1'\n            ) as NodePath<t.ObjectExpression>\n          ).node.properties as t.ObjectProperty[];\n\n          for (const dependency of dependencyProperties) {\n            // skip external dependencies like { vscode: undefined }\n            if (\n              dependency.value.type !== 'NumericLiteral' &&\n              dependency.value.type !== 'StringLiteral'\n            )\n              continue;\n\n            const filePath = getPropName(dependency.key)!;\n            const depId = dependency.value.value.toString();\n            dependencies[depId] = filePath;\n          }\n\n          renameParameters(fn, ['require', 'module', 'exports']);\n          const file = t.file(t.program(fn.node.body.body));\n          const module = new BrowserifyModule(\n            id,\n            file,\n            id === entryId,\n            dependencies\n          );\n          modules.set(id.toString(), module);\n        }\n\n        const resolvedPaths = resolveDependencyTree(dependencyTree, entryId);\n\n        for (const module of modules.values()) {\n          module.path = resolvedPaths[module.id];\n        }\n\n        if (modules.size > 0) {\n          options!.bundle = new BrowserifyBundle(entryId, modules);\n        }\n      },\n      noScope: true,\n    };\n  },\n} satisfies Transform<{ bundle: Bundle | undefined }>;\n", "import assert from 'node:assert';\nimport { dirname, join, relative } from 'node:path/posix';\n\nexport function relativePath(from: string, to: string): string {\n  if (to.startsWith('node_modules/')) return to.replace('node_modules/', '');\n  const relativePath = relative(dirname(from), to);\n  return relativePath.startsWith('.') ? relativePath : './' + relativePath;\n}\n\n/**\n * Resolve the path of each module of a browserify bundle\n * based on its dependencies.\n * @param tree module id -> dependencies (id -> path)\n * @param entry entry module id\n */\nexport function resolveDependencyTree(\n  tree: Record<string, Record<string, string>>,\n  entry: string\n): Record<string, string> {\n  const paths = resolveTreePaths(tree, entry);\n  paths[entry] = './index.js';\n\n  const entryDepth = Object.values(paths).reduce(\n    (acc, path) => Math.max(acc, path.split('..').length),\n    0\n  );\n  // If the entrypoint is in a subfolder, we need to make up a prefix to get rid of the `../`\n  const prefix = Array(entryDepth - 1)\n    .fill(0)\n    .map((_, i) => `tmp${i}`)\n    .join('/');\n\n  return Object.fromEntries(\n    Object.entries(paths).map(([id, path]) => {\n      const newPath = path.startsWith('node_modules/')\n        ? path\n        : join(prefix, path);\n      assert(!newPath.includes('..'));\n      assert(!newPath.startsWith('/'));\n      return [id, newPath];\n    })\n  );\n}\n\n/**\n * Recursively resolve the paths of a dependency tree.\n */\nfunction resolveTreePaths(\n  graph: Record<string, Record<string, string>>,\n  entry: string,\n  cwd = '.',\n  paths: Record<string, string> = {}\n) {\n  const entries = Object.entries(graph[entry]);\n\n  for (const [id, name] of entries) {\n    const isCircular = Object.hasOwn(paths, id);\n    if (isCircular) continue;\n\n    let path: string;\n    if (name.startsWith('.')) {\n      path = join(cwd, name);\n      if (!path.endsWith('.js')) path += '.js';\n    } else {\n      path = join('node_modules', name, 'index.js');\n    }\n    paths[id] = path;\n\n    const newCwd = path.endsWith('.js') ? dirname(path) : path;\n    resolveTreePaths(graph, id, newCwd, paths);\n  }\n\n  return paths;\n}\n", "import traverse from '@babel/traverse';\nimport * as m from '@codemod/matchers';\nimport debug from 'debug';\nimport { dirname, join, normalize } from 'node:path/posix';\nimport { Module } from './module';\n\nconst logger = debug('webcrack:unpack');\n\nexport class Bundle {\n  type: 'webpack' | 'browserify';\n  entryId: string;\n  modules: Map<string, Module>;\n\n  constructor(\n    type: 'webpack' | 'browserify',\n    entryId: string,\n    modules: Map<string, Module>\n  ) {\n    this.type = type;\n    this.entryId = entryId;\n    this.modules = modules;\n  }\n\n  applyMappings(mappings: Record<string, m.Matcher<unknown>>): void {\n    const mappingPaths = Object.keys(mappings);\n    if (mappingPaths.length === 0) return;\n\n    const unusedMappings = new Set(mappingPaths);\n\n    for (const module of this.modules.values()) {\n      traverse(module.ast, {\n        enter(path) {\n          for (const mappingPath of mappingPaths) {\n            if (mappings[mappingPath].match(path.node)) {\n              if (unusedMappings.has(mappingPath)) {\n                unusedMappings.delete(mappingPath);\n              } else {\n                logger(`Mapping ${mappingPath} is already used.`);\n                continue;\n              }\n              const resolvedPath = mappingPath.startsWith('./')\n                ? mappingPath\n                : `node_modules/${mappingPath}`;\n              module.path = resolvedPath;\n              path.stop();\n              break;\n            }\n          }\n        },\n        noScope: true,\n      });\n    }\n\n    if (unusedMappings.size > 0) {\n      logger(`Unused mappings: ${Array.from(unusedMappings).join(', ')}.`);\n    }\n  }\n\n  /**\n   * Saves each module to a file and the bundle metadata to a JSON file.\n   * @param path Output directory\n   */\n  async save(path: string): Promise<void> {\n    const bundleJson = {\n      type: this.type,\n      entryId: this.entryId,\n      modules: Array.from(this.modules.values(), module => ({\n        id: module.id,\n        path: module.path,\n      })),\n    };\n\n    if (process.env.browser) {\n      throw new Error('Not implemented.');\n    } else {\n      const { mkdir, writeFile } = await import('node:fs/promises');\n      await mkdir(path, { recursive: true });\n\n      await writeFile(\n        join(path, 'bundle.json'),\n        JSON.stringify(bundleJson, null, 2),\n        'utf8'\n      );\n\n      await Promise.all(\n        Array.from(this.modules.values(), async module => {\n          const modulePath = normalize(join(path, module.path));\n          if (!modulePath.startsWith(path)) {\n            throw new Error(`detected path traversal: ${module.path}`);\n          }\n          await mkdir(dirname(modulePath), { recursive: true });\n          await writeFile(modulePath, module.code, 'utf8');\n        })\n      );\n    }\n  }\n\n  applyTransforms(): void {}\n}\n", "import { Bundle } from '../bundle';\nimport { BrowserifyModule } from './module';\n\nexport class BrowserifyBundle extends Bundle {\n  constructor(entryId: string, modules: Map<string, BrowserifyModule>) {\n    super('browserify', entryId, modules);\n  }\n}\n", "import generate from '@babel/generator';\nimport * as t from '@babel/types';\n\nexport class Module {\n  id: string;\n  isEntry: boolean;\n  path: string;\n  /**\n   * @internal\n   */\n  ast: t.File;\n  #code: string | undefined;\n\n  constructor(id: string, ast: t.File, isEntry: boolean) {\n    this.id = id;\n    this.ast = ast;\n    this.isEntry = isEntry;\n    this.path = `./${isEntry ? 'index' : id}.js`;\n  }\n\n  /**\n   * @internal\n   */\n  regenerateCode(): string {\n    this.#code = generate(this.ast, { jsescOption: { minimal: true } }).code;\n    return this.#code;\n  }\n\n  get code(): string {\n    return this.#code ?? this.regenerateCode();\n  }\n\n  set code(code: string) {\n    this.#code = code;\n  }\n}\n", "import * as t from '@babel/types';\nimport { Module } from '../module';\n\nexport class BrowserifyModule extends Module {\n  dependencies: Record<number, string>;\n\n  constructor(\n    id: string,\n    ast: t.File,\n    isEntry: boolean,\n    dependencies: Record<number, string>\n  ) {\n    super(id, ast, isEntry);\n    this.dependencies = dependencies;\n  }\n}\n", "import { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport { Transform } from '../../transforms';\nimport { getPropName } from '../../utils/ast';\nimport { constKey, constMemberExpression } from '../../utils/matcher';\nimport { renameParameters } from '../../utils/rename';\nimport { Bundle } from '../bundle';\nimport { WebpackBundle } from './bundle';\nimport { WebpackModule } from './module';\n\nexport const unpackWebpack = {\n  name: 'unpack-webpack',\n  tags: ['unsafe'],\n  visitor(options) {\n    const modules = new Map<string, WebpackModule>();\n\n    const entryIdMatcher = m.capture(m.numericLiteral());\n    const moduleFunctionsMatcher = m.capture(\n      m.or(\n        // E.g. [,,function (e, t, i) {...}, ...], index is the module ID\n        m.arrayExpression(\n          m.arrayOf(\n            m.or(m.functionExpression(), m.arrowFunctionExpression(), null)\n          )\n        ),\n        // E.g. {0: function (e, t, i) {...}, ...}, key is the module ID\n        m.objectExpression(\n          m.arrayOf(\n            m.or(\n              m.objectProperty(\n                m.or(m.numericLiteral(), m.stringLiteral(), m.identifier()),\n                m.or(m.functionExpression(), m.arrowFunctionExpression())\n              ),\n              // __webpack_public_path__ (c: \"\")\n              m.objectProperty(constKey('c'), m.stringLiteral())\n            )\n          )\n        )\n      )\n    );\n\n    const webpack4Matcher = m.callExpression(\n      m.functionExpression(\n        undefined,\n        undefined,\n        m.blockStatement(\n          m.anyList<t.Statement>(\n            m.zeroOrMore(),\n            m.functionDeclaration(),\n            m.zeroOrMore(),\n            m.containerOf(\n              m.or(\n                // E.g. __webpack_require__.s = 2\n                m.assignmentExpression(\n                  '=',\n                  constMemberExpression(m.identifier(), 's'),\n                  entryIdMatcher\n                ),\n                // E.g. return require(0);\n                m.callExpression(m.identifier(), [entryIdMatcher])\n              )\n            )\n          )\n        )\n      ),\n      [moduleFunctionsMatcher]\n    );\n\n    const webpack5Matcher = m.callExpression(\n      m.arrowFunctionExpression(\n        undefined,\n        m.blockStatement(\n          m.anyList<t.Statement>(\n            m.zeroOrMore(),\n            m.variableDeclaration(undefined, [\n              m.variableDeclarator(undefined, moduleFunctionsMatcher),\n            ]),\n            // var installedModules = {};\n            m.variableDeclaration(),\n            m.zeroOrMore(),\n            m.containerOf(\n              // __webpack_require__.s = 2\n              m.assignmentExpression(\n                '=',\n                constMemberExpression(m.identifier(), 's'),\n                entryIdMatcher\n              )\n            ),\n            // module.exports = entryModule\n            m.expressionStatement(\n              m.assignmentExpression(\n                '=',\n                constMemberExpression(m.identifier(), 'exports'),\n                m.identifier()\n              )\n            )\n          )\n        )\n      )\n    );\n\n    // Examples: self.webpackChunk_N_E, window.webpackJsonp, this.webpackJsonp\n    const jsonpGlobal = m.capture(\n      constMemberExpression(\n        m.or(m.identifier(m.or('self', 'window')), m.thisExpression()),\n        m.matcher(s => s.startsWith('webpack'))\n      )\n    );\n    // (window.webpackJsonp = window.webpackJsonp || []).push([[0], {...}])\n    const jsonpMatcher = m.callExpression(\n      constMemberExpression(\n        m.assignmentExpression(\n          '=',\n          jsonpGlobal,\n          m.logicalExpression(\n            '||',\n            m.fromCapture(jsonpGlobal),\n            m.arrayExpression([])\n          )\n        ),\n        'push'\n      ),\n      [\n        m.arrayExpression(\n          m.anyList(\n            m.arrayExpression([m.numericLiteral()]), // chunkId\n            moduleFunctionsMatcher,\n            m.slice({ max: 1 }) // optional entry point like [[\"57iH\",19,24,25]]\n          )\n        ),\n      ]\n    );\n\n    return {\n      CallExpression(path) {\n        if (\n          !webpack4Matcher.match(path.node) &&\n          !webpack5Matcher.match(path.node) &&\n          !jsonpMatcher.match(path.node)\n        )\n          return;\n        path.stop();\n\n        const modulesPath = path.get(\n          moduleFunctionsMatcher.currentKeys!.join('.')\n        ) as NodePath;\n\n        const moduleWrappers = modulesPath.isArrayExpression()\n          ? (modulesPath.get('elements') as NodePath<t.Node | null>[])\n          : (modulesPath.get('properties') as NodePath[]);\n\n        moduleWrappers.forEach((moduleWrapper, index) => {\n          let moduleId = index.toString();\n          if (t.isObjectProperty(moduleWrapper.node)) {\n            moduleId = getPropName(moduleWrapper.node.key)!;\n            moduleWrapper = moduleWrapper.get('value') as NodePath;\n          }\n\n          if (\n            moduleWrapper.isFunction() &&\n            moduleWrapper.node.body.type === 'BlockStatement'\n          ) {\n            renameParameters(moduleWrapper, ['module', 'exports', 'require']);\n            const file = t.file(t.program(moduleWrapper.node.body.body));\n\n            // Remove /***/ comments between modules (in webpack development builds)\n            const lastNode = file.program.body.at(-1);\n            if (\n              lastNode?.trailingComments?.length === 1 &&\n              lastNode.trailingComments[0].value === '*'\n            ) {\n              lastNode.trailingComments = null;\n            }\n\n            const module = new WebpackModule(\n              moduleId,\n              file,\n              moduleId === entryIdMatcher.current?.value.toString()\n            );\n\n            modules.set(moduleId, module);\n          }\n        });\n\n        if (modules.size > 0) {\n          const entryId = entryIdMatcher.current?.value.toString() ?? '';\n          options!.bundle = new WebpackBundle(entryId, modules);\n        }\n      },\n      noScope: true,\n    };\n  },\n} satisfies Transform<{ bundle: Bundle | undefined }>;\n", "import traverse, { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport { relativePath } from '../../utils/path';\nimport { Bundle } from '../bundle';\nimport { convertESM } from './esm';\nimport { convertDefaultRequire } from './getDefaultExport';\nimport { WebpackModule } from './module';\nimport { inlineVarInjections } from './varInjection';\n\nexport class WebpackBundle extends Bundle {\n  constructor(entryId: string, modules: Map<string, WebpackModule>) {\n    super('webpack', entryId, modules);\n  }\n\n  /**\n   * Undoes some of the transformations that Webpack injected into the modules.\n   */\n  applyTransforms(): void {\n    this.modules.forEach(inlineVarInjections);\n    this.modules.forEach(convertESM);\n    convertDefaultRequire(this);\n    this.replaceRequirePaths();\n  }\n\n  /**\n   * Replaces `require(id)` calls with `require(\"./relative/path.js\")` calls.\n   */\n  private replaceRequirePaths() {\n    const requireId = m.capture(m.or(m.numericLiteral(), m.stringLiteral()));\n    const requireMatcher = m.or(\n      m.callExpression(m.identifier('require'), [requireId])\n    );\n    const importId = m.capture(m.stringLiteral());\n    const importMatcher = m.importDeclaration(m.anything(), importId);\n\n    this.modules.forEach(module => {\n      traverse(module.ast, {\n        'CallExpression|ImportDeclaration': path => {\n          let moduleId: string;\n          let arg: NodePath;\n\n          if (requireMatcher.match(path.node)) {\n            moduleId = requireId.current!.value.toString();\n            [arg] = path.get('arguments') as NodePath<t.Identifier>[];\n          } else if (importMatcher.match(path.node)) {\n            moduleId = importId.current!.value;\n            arg = path.get('source') as NodePath;\n          } else {\n            return;\n          }\n\n          const requiredModule = this.modules.get(moduleId);\n          arg.replaceWith(\n            t.stringLiteral(\n              relativePath(\n                module.path,\n                requiredModule?.path ?? `./${moduleId}.js`\n              )\n            )\n          );\n          // For example if its stored in another chunk\n          if (!requiredModule) {\n            arg.addComment('leading', 'webcrack:missing');\n          }\n        },\n        noScope: true,\n      });\n    });\n  }\n}\n", "import { statement } from '@babel/template';\nimport traverse, { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport { constMemberExpression, findPath } from '../../utils/matcher';\nimport { renameFast } from '../../utils/rename';\nimport { WebpackModule } from './module';\n\nconst buildNamespaceImport = statement`import * as NAME from \"PATH\";`;\nconst buildNamedExportLet = statement`export let NAME = VALUE;`;\n\n/**\n * ```js\n * require.r(exports);\n * require.d(exports, 'counter', function () {\n *   return f;\n * });\n * let f = 1;\n * ```\n * ->\n * ```js\n * export let counter = 1;\n * ```\n */\nexport function convertESM(module: WebpackModule): void {\n  // E.g. require.r(exports);\n  const defineEsModuleMatcher = m.expressionStatement(\n    m.callExpression(constMemberExpression('require', 'r'), [m.identifier()])\n  );\n\n  const exportsName = m.capture(m.identifier());\n  const exportedName = m.capture(m.anyString());\n  const returnedValue = m.capture(m.anyExpression());\n  // E.g. require.d(exports, \"counter\", function () { return f });\n  const defineExportMatcher = m.expressionStatement(\n    m.callExpression(constMemberExpression('require', 'd'), [\n      exportsName,\n      m.stringLiteral(exportedName),\n      m.functionExpression(\n        undefined,\n        [],\n        m.blockStatement([m.returnStatement(returnedValue)])\n      ),\n    ])\n  );\n\n  const emptyObjectVarMatcher = m.variableDeclarator(\n    m.fromCapture(exportsName),\n    m.objectExpression([])\n  );\n\n  const properties = m.capture(\n    m.arrayOf(\n      m.objectProperty(\n        m.identifier(),\n        m.arrowFunctionExpression([], m.anyExpression())\n      )\n    )\n  );\n  // E.g. require.d(exports, { foo: () => a, bar: () => b });\n  const defineExportsMatcher = m.expressionStatement(\n    m.callExpression(constMemberExpression('require', 'd'), [\n      exportsName,\n      m.objectExpression(properties),\n    ])\n  );\n\n  // E.g. const lib = require(\"./lib.js\");\n  const requireVariable = m.capture(m.identifier());\n  const requiredModuleId = m.capture(m.anyNumber());\n  const requireMatcher = m.variableDeclaration(undefined, [\n    m.variableDeclarator(\n      requireVariable,\n      m.callExpression(m.identifier('require'), [\n        m.numericLiteral(requiredModuleId),\n      ])\n    ),\n  ]);\n\n  // module = require.hmd(module);\n  const hmdMatcher = m.expressionStatement(\n    m.assignmentExpression(\n      '=',\n      m.identifier('module'),\n      m.callExpression(constMemberExpression('require', 'hmd'))\n    )\n  );\n\n  traverse(module.ast, {\n    enter(path) {\n      // Only traverse the top-level\n      if (path.parentPath?.parentPath) return path.skip();\n\n      if (defineEsModuleMatcher.match(path.node)) {\n        module.ast.program.sourceType = 'module';\n        path.remove();\n      } else if (\n        module.ast.program.sourceType === 'module' &&\n        requireMatcher.match(path.node)\n      ) {\n        path.replaceWith(\n          buildNamespaceImport({\n            NAME: requireVariable.current,\n            PATH: String(requiredModuleId.current),\n          })\n        );\n      } else if (defineExportsMatcher.match(path.node)) {\n        const exportsBinding = path.scope.getBinding(exportsName.current!.name);\n        const emptyObject = emptyObjectVarMatcher.match(\n          exportsBinding?.path.node\n        )\n          ? (exportsBinding!.path.node.init as t.ObjectExpression)\n          : null;\n\n        for (const property of properties.current!) {\n          const exportedKey = property.key as t.Identifier;\n          const returnedValue = (property.value as t.ArrowFunctionExpression)\n            .body as t.Expression;\n          if (emptyObject) {\n            emptyObject.properties.push(\n              t.objectProperty(exportedKey, returnedValue)\n            );\n          } else {\n            exportVariable(path, returnedValue, exportedKey.name);\n          }\n        }\n\n        path.remove();\n      } else if (defineExportMatcher.match(path.node)) {\n        exportVariable(path, returnedValue.current!, exportedName.current!);\n        path.remove();\n      } else if (hmdMatcher.match(path.node)) {\n        path.remove();\n      }\n    },\n  });\n}\n\nfunction exportVariable(\n  requireDPath: NodePath,\n  value: t.Expression,\n  exportName: string\n) {\n  if (value.type === 'Identifier') {\n    const binding = requireDPath.scope.getBinding(value.name);\n    if (!binding) return;\n\n    const declaration = findPath(\n      binding.path,\n      m.or(\n        m.variableDeclaration(),\n        m.classDeclaration(),\n        m.functionDeclaration()\n      )\n    );\n    if (!declaration) return;\n\n    if (exportName === 'default') {\n      // `let f = 1;` -> `export default 1;`\n      declaration.replaceWith(\n        t.exportDefaultDeclaration(\n          t.isVariableDeclaration(declaration.node)\n            ? declaration.node.declarations[0].init!\n            : declaration.node\n        )\n      );\n    } else {\n      // `let f = 1;` -> `export let counter = 1;`\n      renameFast(binding, exportName);\n      declaration.replaceWith(t.exportNamedDeclaration(declaration.node));\n    }\n  } else if (exportName === 'default') {\n    requireDPath.insertAfter(t.exportDefaultDeclaration(value));\n  } else {\n    requireDPath.insertAfter(\n      buildNamedExportLet({ NAME: t.identifier(exportName), VALUE: value })\n    );\n  }\n}\n", "import { expression } from '@babel/template';\nimport traverse, { NodePath } from '@babel/traverse';\nimport * as m from '@codemod/matchers';\nimport { constMemberExpression } from '../../utils/matcher';\nimport { WebpackBundle } from './bundle';\n\n/*\n * webpack/runtime/compat get default export\n * getDefaultExport function for compatibility with non-harmony modules\n * ```js\n * __webpack_require__.n = (module) => {\n * \tvar getter = module && module.__esModule ?\n * \t\t() => (module['default']) :\n * \t\t() => (module);\n * \t__webpack_require__.d(getter, { a: getter });\n * \treturn getter;\n * };\n * ```\n */\n\n/**\n * Convert require.n calls to require the default export depending on the target module type\n * ```js\n * const m = require(1);\n * const getter = require.n(m);\n * console.log(getter.a.prop, getter().prop);\n * ```\n * ->\n * ```js\n * const m = require(1);\n * console.log(m.prop, m.prop);\n * ```\n */\nexport function convertDefaultRequire(bundle: WebpackBundle): void {\n  function getRequiredModule(path: NodePath) {\n    // The variable that's passed to require.n\n    const binding = path.scope.getBinding(moduleArg.current!.name);\n    const declarator = binding?.path.node;\n    if (declaratorMatcher.match(declarator)) {\n      return bundle.modules.get(requiredModuleId.current!.value.toString());\n    }\n  }\n\n  const requiredModuleId = m.capture(m.numericLiteral());\n  // E.g. const m = require(1);\n  const declaratorMatcher = m.variableDeclarator(\n    m.identifier(),\n    m.callExpression(m.identifier('require'), [requiredModuleId])\n  );\n\n  // E.g. m\n  const moduleArg = m.capture(m.identifier());\n  // E.g. getter\n  const getterVarName = m.capture(m.identifier());\n  // E.g. require.n(m)\n  const requireN = m.callExpression(constMemberExpression('require', 'n'), [\n    moduleArg,\n  ]);\n  // E.g. const getter = require.n(m)\n  const defaultRequireMatcher = m.variableDeclarator(getterVarName, requireN);\n\n  // E.g. require.n(m).a or require.n(m)()\n  const defaultRequireMatcherAlternative = m.or(\n    constMemberExpression(requireN, 'a'),\n    m.callExpression(requireN, [])\n  );\n\n  const buildDefaultAccess = expression`OBJECT.default`;\n\n  bundle.modules.forEach(module => {\n    traverse(module.ast, {\n      'CallExpression|MemberExpression'(path) {\n        if (defaultRequireMatcherAlternative.match(path.node)) {\n          // Replace require.n(m).a or require.n(m)() with m or m.default\n          const requiredModule = getRequiredModule(path);\n          if (requiredModule?.ast.program.sourceType === 'module') {\n            path.replaceWith(\n              buildDefaultAccess({ OBJECT: moduleArg.current! })\n            );\n          } else {\n            path.replaceWith(moduleArg.current!);\n          }\n        }\n      },\n      VariableDeclarator(path) {\n        if (defaultRequireMatcher.match(path.node)) {\n          // Replace require.n(m); with m or m.default\n          const requiredModule = getRequiredModule(path);\n          const init = path.get('init');\n          if (requiredModule?.ast.program.sourceType === 'module') {\n            init.replaceWith(\n              buildDefaultAccess({ OBJECT: moduleArg.current! })\n            );\n          } else {\n            init.replaceWith(moduleArg.current!);\n          }\n\n          // Replace getter.a.prop and getter().prop with getter.prop\n          const binding = path.scope.getOwnBinding(getterVarName.current!.name);\n          binding?.referencePaths.forEach(refPath => {\n            if (\n              refPath.parentPath?.isCallExpression() ||\n              refPath.parentPath?.isMemberExpression()\n            ) {\n              refPath.parentPath.replaceWith(refPath);\n            }\n          });\n        }\n      },\n      noScope: true,\n    });\n  });\n}\n", "import { statement } from '@babel/template';\nimport { Statement } from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport { constMemberExpression } from '../../utils/matcher';\nimport { WebpackModule } from './module';\n\nconst buildVar = statement`var NAME = INIT;`;\n\n/**\n * ```js\n * (function(global) {\n *   // ...\n * }.call(exports, require(7)))\n * ```\n * ->\n * ```js\n * var global = require(7);\n * // ...\n * ```\n */\nexport function inlineVarInjections(module: WebpackModule): void {\n  const { program } = module.ast;\n  const newBody: Statement[] = [];\n\n  const body = m.capture(m.blockStatement());\n  const params = m.capture(m.arrayOf(m.identifier()));\n  const args = m.capture(\n    m.anyList(m.or(m.thisExpression(), m.identifier('exports')), m.oneOrMore())\n  );\n  const matcher = m.expressionStatement(\n    m.callExpression(\n      constMemberExpression(\n        m.functionExpression(undefined, params, body),\n        'call'\n      ),\n      args\n    )\n  );\n\n  for (const node of program.body) {\n    if (matcher.match(node)) {\n      const vars = params.current!.map((param, i) =>\n        buildVar({ NAME: param, INIT: args.current![i + 1] })\n      );\n      newBody.push(...vars);\n      newBody.push(...body.current!.body);\n      // We can skip replacing uses of `this` because it always refers to the exports\n    } else {\n      newBody.push(node);\n    }\n  }\n  program.body = newBody;\n}\n", "import { Module } from '../module';\n\nexport class WebpackModule extends Module {}\n", "import * as t from '@babel/types';\nimport { Transform } from '.';\n\nexport default {\n  name: 'blockStatement',\n  tags: ['safe'],\n  visitor: () => ({\n    IfStatement: {\n      exit(path) {\n        if (\n          !t.isBlockStatement(path.node.consequent) &&\n          !t.isEmptyStatement(path.node.consequent)\n        ) {\n          path.node.consequent = t.blockStatement([path.node.consequent]);\n\n          this.changes++;\n        }\n        if (path.node.alternate && !t.isBlockStatement(path.node.alternate)) {\n          path.node.alternate = t.blockStatement([path.node.alternate]);\n          this.changes++;\n        }\n      },\n    },\n    Loop: {\n      exit(path) {\n        if (\n          !t.isBlockStatement(path.node.body) &&\n          !t.isEmptyStatement(path.node.body)\n        ) {\n          path.node.body = t.blockStatement([path.node.body]);\n\n          this.changes++;\n        }\n      },\n    },\n    ArrowFunctionExpression: {\n      exit(path) {\n        if (t.isSequenceExpression(path.node.body)) {\n          path.node.body = t.blockStatement([\n            t.returnStatement(path.node.body),\n          ]);\n\n          this.changes++;\n        }\n      },\n    },\n    noScope: true,\n  }),\n} satisfies Transform;\n", "import * as t from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport { Transform } from '.';\nimport { codePreview } from '../utils/ast';\nimport { constMemberExpression } from '../utils/matcher';\n\nexport default {\n  name: 'jsx',\n  tags: ['unsafe'],\n  visitor: () => {\n    const deepIdentifierMemberExpression = m.memberExpression(\n      m.or(\n        m.identifier(),\n        m.matcher(node => deepIdentifierMemberExpression.match(node))\n      ),\n      m.identifier(),\n      false\n    );\n\n    const type = m.capture(\n      m.or(\n        m.identifier(), // React.createElement(Component, ...)\n        m.stringLiteral(), // React.createElement('div', ...)\n        deepIdentifierMemberExpression // React.createElement(Component.SubComponent, ...)\n      )\n    );\n    const props = m.capture(m.or(m.objectExpression(), m.nullLiteral()));\n\n    // React.createElement(type, props, ...children)\n    const elementMatcher = m.callExpression(\n      constMemberExpression('React', 'createElement'),\n      m.anyList<t.Expression>(type, props, m.zeroOrMore(m.anyExpression()))\n    );\n\n    // React.createElement(React.Fragment, null, ...children)\n    const fragmentMatcher = m.callExpression(\n      constMemberExpression('React', 'createElement'),\n      m.anyList<t.Expression>(\n        constMemberExpression('React', 'Fragment'),\n        m.nullLiteral(),\n        m.zeroOrMore(m.anyExpression())\n      )\n    );\n\n    return {\n      CallExpression: {\n        exit(path) {\n          if (fragmentMatcher.match(path.node)) {\n            const children = convertChildren(\n              path.node.arguments.slice(2) as t.Expression[]\n            );\n            const opening = t.jsxOpeningFragment();\n            const closing = t.jsxClosingFragment();\n            const fragment = t.jsxFragment(opening, closing, children);\n            path.replaceWith(fragment);\n            this.changes++;\n          }\n\n          if (elementMatcher.match(path.node)) {\n            let name = convertType(type.current!);\n\n            // rename component to avoid conflict with built-in html tags\n            // https://react.dev/reference/react/createElement#caveats\n            if (\n              t.isIdentifier(type.current) &&\n              /^[a-z]/.test(type.current.name)\n            ) {\n              const binding = path.scope.getBinding(type.current.name);\n              if (!binding) return;\n              name = t.jsxIdentifier(path.scope.generateUid('Component'));\n              path.scope.rename(type.current.name, name.name);\n            }\n\n            const attributes = t.isObjectExpression(props.current)\n              ? convertAttributes(props.current)\n              : [];\n            const children = convertChildren(\n              path.node.arguments.slice(2) as t.Expression[]\n            );\n            const opening = t.jsxOpeningElement(name, attributes);\n            const closing = t.jsxClosingElement(name);\n            const element = t.jsxElement(opening, closing, children);\n            path.replaceWith(element);\n            this.changes++;\n          }\n        },\n      },\n      noScope: true,\n    };\n  },\n} satisfies Transform;\n\n/**\n * - `Component` -> `Component`\n * - `Component.SubComponent` -> `Component.SubComponent`\n * - `'div'` -> `div`\n */\nfunction convertType(\n  type: t.Identifier | t.MemberExpression | t.StringLiteral\n): t.JSXIdentifier | t.JSXMemberExpression {\n  if (t.isIdentifier(type)) {\n    return t.jsxIdentifier(type.name);\n  } else if (t.isStringLiteral(type)) {\n    return t.jsxIdentifier(type.value);\n  } else {\n    const object = convertType(\n      type.object as t.Identifier | t.MemberExpression\n    );\n    const property = t.jsxIdentifier((type.property as t.Identifier).name);\n    return t.jsxMemberExpression(object, property);\n  }\n}\n\n/**\n * `{ className: 'foo', style: { display: 'block' } }`\n * ->\n * `className='foo' style={{ display: 'block' }}`\n */\nfunction convertAttributes(\n  object: t.ObjectExpression\n): (t.JSXAttribute | t.JSXSpreadAttribute)[] {\n  const name = m.capture(m.anyString());\n  const value = m.capture(m.anyExpression());\n  const matcher = m.objectProperty(\n    m.or(m.identifier(name), m.stringLiteral(name)),\n    value\n  );\n\n  return object.properties.map(property => {\n    if (matcher.match(property)) {\n      const jsxName = t.jsxIdentifier(name.current!);\n      const jsxValue =\n        value.current!.type === 'StringLiteral'\n          ? value.current\n          : t.jsxExpressionContainer(value.current!);\n      return t.jsxAttribute(jsxName, jsxValue);\n    } else if (t.isSpreadElement(property)) {\n      return t.jsxSpreadAttribute(property.argument);\n    } else {\n      throw new Error(\n        `jsx: property type not implemented ${codePreview(object)}`\n      );\n    }\n  });\n}\n\nfunction convertChildren(\n  children: t.Expression[]\n): (t.JSXText | t.JSXElement | t.JSXExpressionContainer)[] {\n  return children.map(child => {\n    if (t.isJSXElement(child)) {\n      return child;\n    } else if (t.isStringLiteral(child)) {\n      return t.jsxText(child.value);\n    } else {\n      return t.jsxExpressionContainer(child);\n    }\n  });\n}\n", "import * as t from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport { Transform } from '.';\nimport { codePreview } from '../utils/ast';\nimport { constMemberExpression } from '../utils/matcher';\n\n/**\n * https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md\n * https://new-jsx-transform.netlify.app/\n */\nexport default {\n  name: 'jsx-new',\n  tags: ['unsafe'],\n  visitor: () => {\n    const deepIdentifierMemberExpression = m.memberExpression(\n      m.or(\n        m.identifier(),\n        m.matcher(node => deepIdentifierMemberExpression.match(node))\n      ),\n      m.identifier(),\n      false\n    );\n\n    const type = m.capture(\n      m.or(\n        m.identifier(), // jsx(Component, ...)\n        m.stringLiteral(), // jsx('div', ...)\n        deepIdentifierMemberExpression // jsx(Component.SubComponent, ...)\n      )\n    );\n    const fragmentType = constMemberExpression('React', 'Fragment');\n    const props = m.capture(m.objectExpression());\n    const key = m.capture(m.anyExpression());\n\n    const jsxFunction = m.capture(m.or('jsx' as const, 'jsxs' as const));\n    // jsx(type, props, key?)\n    const jsxMatcher = m.callExpression(\n      m.identifier(jsxFunction),\n      m.anyList(type, props, m.slice({ min: 0, max: 1, matcher: key }))\n    );\n\n    return {\n      CallExpression: {\n        exit(path) {\n          if (!jsxMatcher.match(path.node)) return;\n\n          let name = convertType(type.current!);\n          const isFragment = fragmentType.match(type.current);\n\n          // rename component to avoid conflict with built-in html tags\n          // https://react.dev/reference/react/createElement#caveats\n          if (\n            t.isIdentifier(type.current) &&\n            /^[a-z]/.test(type.current.name)\n          ) {\n            const binding = path.scope.getBinding(type.current.name);\n            if (!binding) return;\n            name = t.jsxIdentifier(path.scope.generateUid('Component'));\n            path.scope.rename(type.current.name, name.name);\n          }\n\n          const attributes = convertAttributes(props.current!);\n          if (path.node.arguments.length === 3) {\n            attributes.push(\n              t.jsxAttribute(\n                t.jsxIdentifier('key'),\n                convertAttributeValue(key.current!)\n              )\n            );\n          }\n          const children = convertChildren(\n            props.current!,\n            jsxFunction.current!\n          );\n\n          if (isFragment && attributes.length === 0) {\n            const opening = t.jsxOpeningFragment();\n            const closing = t.jsxClosingFragment();\n            const fragment = t.jsxFragment(opening, closing, children);\n            path.replaceWith(fragment);\n          } else {\n            const opening = t.jsxOpeningElement(name, attributes);\n            const closing = t.jsxClosingElement(name);\n            const element = t.jsxElement(opening, closing, children);\n            path.replaceWith(element);\n          }\n          this.changes++;\n        },\n      },\n      noScope: true,\n    };\n  },\n} satisfies Transform;\n\n/**\n * - `Component` -> `Component`\n * - `Component.SubComponent` -> `Component.SubComponent`\n * - `'div'` -> `div`\n */\nfunction convertType(\n  type: t.Identifier | t.MemberExpression | t.StringLiteral\n): t.JSXIdentifier | t.JSXMemberExpression {\n  if (t.isIdentifier(type)) {\n    return t.jsxIdentifier(type.name);\n  } else if (t.isStringLiteral(type)) {\n    return t.jsxIdentifier(type.value);\n  } else {\n    const object = convertType(\n      type.object as t.Identifier | t.MemberExpression\n    );\n    const property = t.jsxIdentifier((type.property as t.Identifier).name);\n    return t.jsxMemberExpression(object, property);\n  }\n}\n\n/**\n * `{ className: 'foo', style: { display: 'block' } }`\n * ->\n * `className='foo' style={{ display: 'block' }}`\n */\nfunction convertAttributes(\n  object: t.ObjectExpression\n): (t.JSXAttribute | t.JSXSpreadAttribute)[] {\n  const name = m.capture(m.anyString());\n  const value = m.capture(m.anyExpression());\n  const matcher = m.objectProperty(\n    m.or(m.identifier(name), m.stringLiteral(name)),\n    value\n  );\n\n  return object.properties.flatMap(property => {\n    if (matcher.match(property)) {\n      if (name.current === 'children') return [];\n\n      const jsxName = t.jsxIdentifier(name.current!);\n      const jsxValue = convertAttributeValue(value.current!);\n      return t.jsxAttribute(jsxName, jsxValue);\n    } else if (t.isSpreadElement(property)) {\n      return t.jsxSpreadAttribute(property.argument);\n    } else {\n      throw new Error(\n        `jsx: property type not implemented ${codePreview(object)}`\n      );\n    }\n  });\n}\n\nfunction convertAttributeValue(\n  expression: t.Expression\n): t.JSXExpressionContainer | t.StringLiteral {\n  return expression.type === 'StringLiteral'\n    ? expression\n    : t.jsxExpressionContainer(expression);\n}\n\nfunction convertChildren(\n  object: t.ObjectExpression,\n  fn: 'jsx' | 'jsxs'\n): (t.JSXText | t.JSXElement | t.JSXExpressionContainer)[] {\n  const children = m.capture(m.anyExpression());\n  const matcher = m.objectProperty(\n    m.or(m.identifier('children'), m.stringLiteral('children')),\n    children\n  );\n\n  const prop = object.properties.find(prop => matcher.match(prop));\n  if (!prop) return [];\n\n  if (fn === 'jsxs' && t.isArrayExpression(children.current)) {\n    return children.current.elements.map(child =>\n      convertChild(child as t.Expression)\n    );\n  }\n  return [convertChild(children.current!)];\n}\n\nfunction convertChild(\n  child: t.Expression\n): t.JSXElement | t.JSXExpressionContainer | t.JSXText {\n  if (t.isJSXElement(child)) {\n    return child;\n  } else if (t.isStringLiteral(child)) {\n    return t.jsxText(child.value);\n  } else {\n    return t.jsxExpressionContainer(child);\n  }\n}\n", "import traverse, { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport mangle from 'babel-plugin-minify-mangle-names';\nimport { Transform } from '.';\n\nexport default {\n  name: 'mangle',\n  tags: ['safe'],\n  run(ast) {\n    // path.hub is undefined for some reason, monkey-patch to avoid error...\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const { getSource } = NodePath.prototype;\n    NodePath.prototype.getSource = () => '';\n\n    traverse(ast, mangle({ types: t, traverse }).visitor, undefined, {\n      opts: {\n        eval: true,\n        topLevel: true,\n        exclude: { React: true },\n      },\n    });\n\n    NodePath.prototype.getSource = getSource;\n  },\n} satisfies Transform;\n", "import * as t from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport { Transform } from '.';\n\nexport default {\n  name: 'sequence',\n  tags: ['safe'],\n  visitor: () => ({\n    ExpressionStatement: {\n      exit(path) {\n        if (t.isSequenceExpression(path.node.expression)) {\n          const statements = path.node.expression.expressions.map(expr =>\n            t.expressionStatement(expr)\n          );\n          path.replaceWithMultiple(statements);\n          this.changes++;\n        }\n      },\n    },\n    ReturnStatement: {\n      exit(path) {\n        if (t.isSequenceExpression(path.node.argument)) {\n          const expressions = path.node.argument.expressions;\n          path.node.argument = expressions.pop();\n          const statements = expressions.map(expr =>\n            t.expressionStatement(expr)\n          );\n          path.insertBefore(statements);\n          this.changes++;\n        } else if (\n          t.isUnaryExpression(path.node.argument, { operator: 'void' }) &&\n          t.isSequenceExpression(path.node.argument.argument)\n        ) {\n          const expressions = path.node.argument.argument.expressions;\n          const statements = expressions.map(expr =>\n            t.expressionStatement(expr)\n          );\n          path.insertBefore(statements);\n          path.node.argument = null;\n          this.changes++;\n        }\n      },\n    },\n    IfStatement: {\n      exit(path) {\n        if (t.isSequenceExpression(path.node.test)) {\n          const expressions = path.node.test.expressions;\n          path.node.test = expressions.pop()!;\n          const statements = expressions.map(expr =>\n            t.expressionStatement(expr)\n          );\n          path.insertBefore(statements);\n          this.changes++;\n        }\n      },\n    },\n    SwitchStatement: {\n      exit(path) {\n        if (t.isSequenceExpression(path.node.discriminant)) {\n          const expressions = path.node.discriminant.expressions;\n          path.node.discriminant = expressions.pop()!;\n          const statements = expressions.map(expr =>\n            t.expressionStatement(expr)\n          );\n          path.insertBefore(statements);\n          this.changes++;\n        }\n      },\n    },\n    ThrowStatement: {\n      exit(path) {\n        if (t.isSequenceExpression(path.node.argument)) {\n          const expressions = path.node.argument.expressions;\n          path.node.argument = expressions.pop()!;\n          const statements = expressions.map(expr =>\n            t.expressionStatement(expr)\n          );\n          path.insertBefore(statements);\n          this.changes++;\n        }\n      },\n    },\n    ForInStatement: {\n      exit(path) {\n        const sequence = m.capture(m.sequenceExpression());\n        const matcher = m.forInStatement(m.anything(), sequence);\n        if (matcher.match(path.node)) {\n          const expressions = sequence.current!.expressions;\n          path.node.right = expressions.pop()!;\n          const statements = expressions.map(expr =>\n            t.expressionStatement(expr)\n          );\n          path.insertBefore(statements);\n          this.changes++;\n        }\n      },\n    },\n    ForStatement: {\n      exit(path) {\n        if (t.isSequenceExpression(path.node.init)) {\n          const statements = path.node.init.expressions.map(expr =>\n            t.expressionStatement(expr)\n          );\n          path.insertBefore(statements);\n          path.node.init = null;\n          this.changes++;\n        }\n      },\n    },\n    VariableDeclaration: {\n      exit(path) {\n        const sequence = m.capture(m.sequenceExpression());\n        const matcher = m.variableDeclaration(undefined, [\n          m.variableDeclarator(undefined, sequence),\n        ]);\n        if (matcher.match(path.node)) {\n          const expressions = sequence.current!.expressions;\n          path.node.declarations[0].init = expressions.pop();\n          const statements = expressions.map(expr =>\n            t.expressionStatement(expr)\n          );\n          if (path.parentPath.isForStatement() && path.key === 'init') {\n            path.parentPath.insertBefore(statements);\n          } else {\n            path.insertBefore(statements);\n          }\n          this.changes++;\n        }\n      },\n    },\n    noScope: true,\n  }),\n} satisfies Transform;\n", "import * as t from '@babel/types';\nimport { Transform } from '.';\n\nexport default {\n  name: 'splitVariableDeclarations',\n  tags: ['safe'],\n  visitor: () => ({\n    VariableDeclaration: {\n      exit(path) {\n        if (path.node.declarations.length > 1 && path.key !== 'init') {\n          if (path.parentPath.isExportNamedDeclaration()) {\n            path.parentPath.replaceWithMultiple(\n              path.node.declarations.map(declaration =>\n                t.exportNamedDeclaration(\n                  t.variableDeclaration(path.node.kind, [declaration])\n                )\n              )\n            );\n          } else {\n            path.replaceWithMultiple(\n              path.node.declarations.map(declaration =>\n                t.variableDeclaration(path.node.kind, [declaration])\n              )\n            );\n          }\n          this.changes++;\n        }\n      },\n    },\n    noScope: true,\n  }),\n} satisfies Transform;\n", "import { statement } from '@babel/template';\nimport * as t from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport { Transform } from '.';\n\nexport default {\n  name: 'booleanIf',\n  tags: ['safe'],\n  visitor: () => {\n    const andMatcher = m.expressionStatement(m.logicalExpression('&&'));\n    const orMatcher = m.expressionStatement(m.logicalExpression('||'));\n\n    const buildIf = statement`if (TEST) { BODY; }`;\n    const buildIfNot = statement`if (!TEST) { BODY; }`;\n\n    return {\n      ExpressionStatement: {\n        exit(path) {\n          const expression = path.node.expression as t.LogicalExpression;\n          if (andMatcher.match(path.node)) {\n            path.replaceWith(\n              buildIf({\n                TEST: expression.left,\n                BODY: expression.right,\n              })\n            );\n            this.changes++;\n          } else if (orMatcher.match(path.node)) {\n            path.replaceWith(\n              buildIfNot({\n                TEST: expression.left,\n                BODY: expression.right,\n              })\n            );\n            this.changes++;\n          }\n        },\n      },\n      noScope: true,\n    };\n  },\n} satisfies Transform;\n", "import { isIdentifierName } from '@babel/helper-validator-identifier';\nimport * as t from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport { Transform } from '.';\n\nexport default {\n  name: 'computedProperties',\n  tags: ['safe'],\n  visitor() {\n    const stringMatcher = m.capture(\n      m.stringLiteral(m.matcher(value => isIdentifierName(value)))\n    );\n    const propertyMatcher = m.or(\n      m.memberExpression(m.anything(), stringMatcher, true),\n      m.optionalMemberExpression(m.anything(), stringMatcher, true)\n    );\n    const keyMatcher = m.or(\n      m.objectProperty(stringMatcher),\n      m.classProperty(stringMatcher),\n      m.objectMethod(undefined, stringMatcher),\n      m.classMethod(undefined, stringMatcher)\n    );\n\n    return {\n      'MemberExpression|OptionalMemberExpression': {\n        exit(path) {\n          if (propertyMatcher.match(path.node)) {\n            path.node.computed = false;\n            path.node.property = t.identifier(stringMatcher.current!.value);\n            this.changes++;\n          }\n        },\n      },\n      'ObjectProperty|ClassProperty|ObjectMethod|ClassMethod': {\n        exit(path) {\n          if (keyMatcher.match(path.node)) {\n            path.node.computed = false;\n            path.node.key = t.identifier(stringMatcher.current!.value);\n            this.changes++;\n          }\n        },\n      },\n      noScope: true,\n    };\n  },\n} satisfies Transform;\n", "import { parseExpression } from '@babel/parser';\nimport * as m from '@codemod/matchers';\nimport { Transform } from '.';\nimport { constMemberExpression } from '../utils/matcher';\n\nexport default {\n  name: 'jsonParse',\n  tags: ['safe'],\n  visitor: () => {\n    const string = m.capture(m.anyString());\n    const matcher = m.callExpression(constMemberExpression('JSON', 'parse'), [\n      m.stringLiteral(string),\n    ]);\n\n    return {\n      CallExpression: {\n        exit(path) {\n          if (matcher.match(path.node)) {\n            try {\n              JSON.parse(string.current!);\n              const parsed = parseExpression(string.current!);\n              path.replaceWith(parsed);\n              this.changes++;\n            } catch (error) {\n              // ignore\n            }\n          }\n        },\n      },\n      noScope: true,\n    };\n  },\n} satisfies Transform;\n", "import { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport { Transform } from '.';\n\nexport default {\n  name: 'mergeElseIf',\n  tags: ['safe'],\n  visitor() {\n    const nestedIf = m.capture(m.ifStatement());\n    const matcher = m.ifStatement(\n      m.anything(),\n      m.anything(),\n      m.blockStatement([nestedIf])\n    );\n\n    return {\n      IfStatement: {\n        exit(path) {\n          if (matcher.match(path.node)) {\n            const alternate = path.get('alternate') as NodePath<t.BlockStatement>;\n            alternate.replaceWith(nestedIf.current!);\n            this.changes++;\n          }\n        },\n      },\n      noScope: true,\n    };\n  },\n} satisfies Transform;\n", "import * as t from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport { Transform } from '.';\n\nexport default {\n  name: 'numberExpressions',\n  tags: ['safe'],\n  visitor: () => ({\n    'BinaryExpression|UnaryExpression': {\n      exit(path) {\n        if (matcher.match(path.node)) {\n          const evaluated = path.evaluate();\n          if (evaluated.confident) {\n            path.replaceWith(t.valueToNode(evaluated.value));\n            path.skip();\n            this.changes++;\n          }\n        }\n      },\n    },\n    noScope: true,\n  }),\n} satisfies Transform;\n\nconst matcher: m.Matcher<t.Expression> = m.or(\n  m.binaryExpression(\n    m.or('+', '-', '*'),\n    m.matcher(node => matcher.match(node)),\n    m.matcher(node => matcher.match(node))\n  ),\n  m.binaryExpression(\n    '-',\n    m.or(\n      m.stringLiteral(),\n      m.matcher(node => matcher.match(node))\n    ),\n    m.or(\n      m.stringLiteral(),\n      m.matcher(node => matcher.match(node))\n    )\n  ),\n  m.unaryExpression(\n    '-',\n    m.or(\n      m.stringLiteral(),\n      m.matcher(node => matcher.match(node))\n    )\n  ),\n  m.numericLiteral()\n);\n", "import { Transform } from '.';\n\nexport default {\n  name: 'rawLiterals',\n  tags: ['safe'],\n  visitor: () => ({\n    StringLiteral(path) {\n      if (path.node.extra) {\n        path.node.extra = undefined;\n        this.changes++;\n      }\n    },\n    NumericLiteral(path) {\n      if (path.node.extra) {\n        path.node.extra = undefined;\n        this.changes++;\n      }\n    },\n    noScope: true,\n  }),\n} satisfies Transform;\n", "import { statement } from '@babel/template';\nimport * as m from '@codemod/matchers';\nimport { Transform } from '.';\n\nexport default {\n  name: 'ternaryToIf',\n  tags: ['safe'],\n  visitor() {\n    const test = m.capture(m.anyExpression());\n    const consequent = m.capture(m.anyExpression());\n    const alternate = m.capture(m.anyExpression());\n    const conditional = m.conditionalExpression(test, consequent, alternate);\n\n    const buildIf = statement`if (TEST) { CONSEQUENT; } else { ALTERNATE; }`;\n    const buildIfReturn = statement`if (TEST) { return CONSEQUENT; } else { return ALTERNATE; }`;\n\n    return {\n      ExpressionStatement: {\n        exit(path) {\n          if (conditional.match(path.node.expression)) {\n            path.replaceWith(\n              buildIf({\n                TEST: test.current,\n                CONSEQUENT: consequent.current,\n                ALTERNATE: alternate.current,\n              })\n            );\n            this.changes++;\n          }\n        },\n      },\n      ReturnStatement: {\n        exit(path) {\n          if (conditional.match(path.node.argument)) {\n            path.replaceWith(\n              buildIfReturn({\n                TEST: test.current,\n                CONSEQUENT: consequent.current,\n                ALTERNATE: alternate.current,\n              })\n            );\n            this.changes++;\n          }\n        },\n      },\n      noScope: true,\n    };\n  },\n} satisfies Transform;\n", "import * as t from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport { Transform } from '.';\n\nexport default {\n  name: 'unminifyBooleans',\n  tags: ['safe'],\n  visitor: () => ({\n    UnaryExpression(path) {\n      if (trueMatcher.match(path.node)) {\n        path.replaceWith(t.booleanLiteral(true));\n        this.changes++;\n      } else if (falseMatcher.match(path.node)) {\n        path.replaceWith(t.booleanLiteral(false));\n        this.changes++;\n      }\n    },\n    noScope: true,\n  }),\n} satisfies Transform;\n\nconst trueMatcher = m.or(\n  m.unaryExpression('!', m.numericLiteral(0)),\n  m.unaryExpression('!', m.unaryExpression('!', m.numericLiteral(1))),\n  m.unaryExpression('!', m.unaryExpression('!', m.arrayExpression([])))\n);\n\nconst falseMatcher = m.or(\n  m.unaryExpression('!', m.numericLiteral(1)),\n  m.unaryExpression('!', m.arrayExpression([]))\n);\n", "import * as t from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport { Transform } from '.';\n\nexport default {\n  name: 'void0ToUndefined',\n  tags: ['safe'],\n  visitor: () => {\n    const matcher = m.unaryExpression('void', m.numericLiteral(0));\n    return {\n      UnaryExpression: {\n        exit(path) {\n          if (matcher.match(path.node)) {\n            path.replaceWith(t.identifier('undefined'));\n            this.changes++;\n          }\n        },\n      },\n      noScope: true,\n    };\n  },\n} satisfies Transform;\n", "import * as t from '@babel/types';\nimport * as m from '@codemod/matchers';\nimport { Transform } from '.';\n\n// https://eslint.org/docs/latest/rules/yoda and https://babeljs.io/docs/en/babel-plugin-minify-flip-comparisons\n\nconst flippedOperators = {\n  '==': '==',\n  '===': '===',\n  '!=': '!=',\n  '!==': '!==',\n  '>': '<',\n  '<': '>',\n  '>=': '<=',\n  '<=': '>=',\n  '*': '*',\n  '^': '^',\n  '&': '&',\n  '|': '|',\n} as const;\n\nexport default {\n  name: 'yoda',\n  tags: ['safe'],\n  visitor: () => {\n    const matcher = m.binaryExpression(\n      m.or(...Object.values(flippedOperators)),\n      m.or(\n        m.stringLiteral(),\n        m.numericLiteral(),\n        m.unaryExpression('-', m.numericLiteral()),\n        m.booleanLiteral(),\n        m.nullLiteral(),\n        m.identifier('undefined'),\n        m.identifier('NaN'),\n        m.identifier('Infinity')\n      ),\n      m.matcher(node => !t.isLiteral(node))\n    );\n\n    return {\n      BinaryExpression: {\n        exit({ node }) {\n          if (matcher.match(node)) {\n            [node.left, node.right] = [node.right, node.left as t.Expression];\n            node.operator =\n              flippedOperators[node.operator as keyof typeof flippedOperators];\n            this.changes++;\n          }\n        },\n      },\n      noScope: true,\n    };\n  },\n} satisfies Transform;\n", "import { Visitor, visitors } from '@babel/traverse';\nimport { Transform, TransformState } from '.';\nimport blockStatement from './blockStatement';\nimport booleanIf from './booleanIf';\nimport computedProperties from './computedProperties';\nimport jsonParse from './jsonParse';\nimport mergeElseIf from './mergeElseIf';\nimport mergeStrings from './mergeStrings';\nimport numberExpressions from './numberExpressions';\nimport rawLiterals from './rawLiterals';\nimport sequence from './sequence';\nimport splitVariableDeclarations from './splitVariableDeclarations';\nimport ternaryToIf from './ternaryToIf';\nimport unminifyBooleans from './unminifyBooleans';\nimport void0ToUndefined from './void0ToUndefined';\nimport yoda from './yoda';\n\nexport default {\n  name: 'unminify',\n  tags: ['safe'],\n  visitor() {\n    const traverseOptions: Visitor<TransformState>[] = [\n      rawLiterals.visitor(),\n      blockStatement.visitor(),\n      mergeStrings.visitor(),\n      computedProperties.visitor(),\n      splitVariableDeclarations.visitor(),\n      sequence.visitor(),\n      numberExpressions.visitor(),\n      unminifyBooleans.visitor(),\n      booleanIf.visitor(),\n      ternaryToIf.visitor(),\n      mergeElseIf.visitor(),\n      void0ToUndefined.visitor(),\n      yoda.visitor(),\n      jsonParse.visitor(),\n    ];\n    const visitor = visitors.merge(traverseOptions);\n    // @ts-expect-error regression from https://github.com/babel/babel/pull/15702\n    visitor.noScope = traverseOptions.every(t => t.noScope);\n    return visitor;\n  },\n} satisfies Transform;\n"],
  "mappings": "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",
  "names": ["m", "debug", "normalize", "debug", "lib_star", "module", "t", "matcher", "m", "callExpression", "m", "matcher", "path", "callExpression", "matcher", "t", "m", "t", "t", "m", "matcher", "binding", "ref", "t", "m", "expressionStatement", "t", "m", "matcher", "t", "m", "m", "matcher", "t", "m", "m", "arrayExpression", "variableDeclaration", "matcher", "debug", "debug", "logger", "debug", "m", "ifStatement", "matcher", "ifStatement", "t", "m", "m", "matcher", "debug", "t", "m", "assert", "relativePath", "debug", "logger", "module", "join", "dirname", "matcher", "file", "module", "t", "m", "t", "m", "t", "m", "module", "returnedValue", "expression", "m", "expression", "module", "statement", "m", "statement", "module", "program", "matcher", "module", "file", "module", "debug", "t", "t", "m", "matcher", "t", "m", "convertType", "convertAttributes", "convertChildren", "matcher", "expression", "prop", "t", "t", "m", "matcher", "t", "statement", "m", "expression", "t", "m", "m", "matcher", "m", "matcher", "t", "m", "matcher", "statement", "m", "t", "m", "trueMatcher", "falseMatcher", "t", "m", "matcher", "t", "m", "matcher", "t", "debug", "m", "normalize", "join"]
}
